###################################################
#
# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
###################################################

###################################################
#
# DO NOT EDIT THIS FILE!
#
# Instead, edit messages.xml. The ant MessageBuilder task takes
# messages.xml as input and from it generates this file.
#
###################################################


01001=Une tentative de mise \u00E0 jour ou de suppression d''une ligne d\u00E9j\u00E0 supprim\u00E9e a \u00E9t\u00E9 effectu\u00E9e : aucune ligne n''a \u00E9t\u00E9 mise \u00E0 jour ou supprim\u00E9e.

01003=Les valeurs NULL ont \u00E9t\u00E9 \u00E9limin\u00E9es de l''argument d''une fonction de colonne.

# Arguments:
#
#    {0} = authorizationID
#
01006=Le privil\u00E8ge de l''utilisateur {0} n''a pas \u00E9t\u00E9 r\u00E9voqu\u00E9.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01007=R\u00F4le {0} non r\u00E9voqu\u00E9 de l''ID d''authentification {1}.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
01008=WITH ADMIN OPTION du r\u00F4le {0} non r\u00E9voqu\u00E9 de l''ID d''authentification {1}.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01009=La colonne g\u00E9n\u00E9r\u00E9e {0} a \u00E9t\u00E9 supprim\u00E9e de la table {1}.

0100E=Tentative de renvoi d''un trop grand nombre d''ensembles de r\u00E9sultats. 

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
01500=La contrainte {0} sur la table {1} a \u00E9t\u00E9 supprim\u00E9e.

# Arguments:
#
#    {0} = viewName
#
01501=La vue {0} a \u00E9t\u00E9 supprim\u00E9e.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
01502=Le d\u00E9clencheur {0} sur la table {1} a \u00E9t\u00E9 supprim\u00E9.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
01503=La colonne {0} sur la table {1} a \u00E9t\u00E9 modifi\u00E9e par l''ajout d''une contrainte non NULL.

# Arguments:
#
#    {0} = indexName
#
01504=Le nouvel index est un doublon d''un index existant : {0}.

# Arguments:
#
#    {0} = dataValue
#
01505=La valeur {0} est peut-\u00EAtre tronqu\u00E9e.

# Arguments:
#
#    {0} = synonymName
#    {1} = objectName
#
01522=Le synonyme nouvellement d\u00E9fini ''{0}'' a \u00E9t\u00E9 r\u00E9solu en objet ''{1}'' qui n''est pas d\u00E9fini actuellement.

# Arguments:
#
#    {0} = databaseName
#
01J01=La base de donn\u00E9es ''{0}'' n''est pas cr\u00E9\u00E9e, la connexion a donc \u00E9t\u00E9 \u00E9tablie avec une base de donn\u00E9es existante.

01J02=Les curseurs sensibles au d\u00E9filement ne sont pas impl\u00E9ment\u00E9s actuellement.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
01J04=La classe ''{0}'' de la colonne ''{1}'' n''impl\u00E9mente pas java.io.Serializable ou java.sql.SQLData. Des instances doivent impl\u00E9menter l''une de ces interfaces pour permettre leur stockage.

01J05=La mise \u00E0 niveau de la base de donn\u00E9es a abouti. La base de donn\u00E9es mise \u00E0 niveau est d\u00E9sormais pr\u00EAte \u00E0 \u00EAtre utilis\u00E9e. Echec de la revalidation des instructions pr\u00E9par\u00E9es stock\u00E9es. Pour plus de d\u00E9tails sur cet \u00E9chec, reportez-vous \u00E0 l''exception suivante.

01J06=L''\u00E9l\u00E9ment ResultSet ne peut pas \u00EAtre mis \u00E0 jour. La requ\u00EAte n''est pas qualifi\u00E9e pour g\u00E9n\u00E9rer un \u00E9l\u00E9ment ResultSet pouvant \u00EAtre mis \u00E0 jour.

01J07=L''\u00E9l\u00E9ment ResultSetHoldability est limit\u00E9 \u00E0 ResultSet.CLOSE_CURSORS_AT_COMMIT dans le cadre d''une transaction globale.

# Arguments:
#
#    {0} = resultSetType
#    {1} = resultSetType
#
01J08=Impossible d''ouvrir l''\u00E9l\u00E9ment resultSet de type {0}. L''\u00E9l\u00E9ment resultSet de type {1} a \u00E9t\u00E9 ouvert.

01J10=Les ensembles de r\u00E9sultats sensibles au d\u00E9filement ne sont pas pris en charge par le serveur ; nouvelle mise en correspondance avec le curseur de type forward-only

01J12=Impossible d''obtenir un texte de message du serveur. Consultez l''exception suivante. La proc\u00E9dure stock\u00E9e SYSIBM.SQLCAMESSAGE n''est pas install\u00E9e sur le serveur. Contactez l''administrateur de base de donn\u00E9es.

# Arguments:
#
#    {0} = number
#
01J13=Le nombre de lignes renvoy\u00E9 ({0}) est trop important pour correspondre \u00E0 un entier ; la valeur renvoy\u00E9e sera tronqu\u00E9e.

01J14=L''autorisation SQL est utilis\u00E9e sans activation pr\u00E9alable de l''authentification.

# Arguments:
#
#    {0} = remainingDays
#    {1} = databaseName
#
01J15=Votre mot de passe expirera dans {0} jour(s). Utilisez la proc\u00E9dure SYSCS_UTIL.SYSCS_MODIFY_PASSWORD pour modifier le mot de passe dans la base de donn\u00E9es ''{1}''.

# Arguments:
#
#    {0} = databaseName
#
01J16=Votre mot de passe est obsol\u00E8te. Pour prot\u00E9ger la base de donn\u00E9es, vous devez mettre \u00E0 jour votre mot de passe rapidement. Utilisez la proc\u00E9dure SYSCS_UTIL.SYSCS_MODIFY_PASSWORD pour modifier le mot de passe dans la base de donn\u00E9es ''{0}''.

07000=Au moins un param\u00E8tre de l''instruction en cours n''est pas initialis\u00E9.

# Arguments:
#
#    {0} = parameterName
#    {1} = procedureName
#
07004=Le param\u00E8tre {0} est un param\u00E8tre de proc\u00E9dure {1} et doit \u00EAtre inscrit aupr\u00E8s de CallableStatement.registerOutParameter avant son ex\u00E9cution.

07009=Aucun param\u00E8tre d''entr\u00E9e.

08000=Connexion ferm\u00E9e par une interruption inconnue.

08001.C.10=Aucune connexion n''a pu \u00EAtre \u00E9tablie car le jeton de s\u00E9curit\u00E9 est plus grand que la taille maximale autoris\u00E9e par le protocole r\u00E9seau.

08001.C.11=Aucune connexion n''a pu \u00EAtre \u00E9tablie car l''ID utilisateur a une longueur \u00E9gale \u00E0 z\u00E9ro ou est plus long que le maximum autoris\u00E9 par le protocole r\u00E9seau.

08001.C.12=Aucune connexion n''a pu \u00EAtre \u00E9tablie car le mot de passe a une longueur \u00E9gale \u00E0 z\u00E9ro ou est plus long que le maximum autoris\u00E9 par le protocole r\u00E9seau.

08001.C.13=Aucune connexion n''a pu \u00EAtre \u00E9tablie car le nom externe (EXTNAM) a une longueur \u00E9gale \u00E0 z\u00E9ro ou est plus long que le maximum autoris\u00E9 par le protocole r\u00E9seau.

08001.C.14=Aucune connexion n''a pu \u00EAtre \u00E9tablie car le nom de serveur (SRVNAM) a une longueur \u00E9gale \u00E0 z\u00E9ro ou est plus long que le maximum autoris\u00E9 par le protocole r\u00E9seau.

# Arguments:
#
#    {0} = propertyName
#
08001.C.1=La propri\u00E9t\u00E9 de source de donn\u00E9es Derby requise {0} n''a pas \u00E9t\u00E9 d\u00E9finie.

# Arguments:
#
#    {0} = error
#    {1} = serverName
#    {2} = portNumber
#    {3} = messageText
#
08001.C.2={0} : erreur lors de la connexion au serveur {1} sur le port {2} avec le message {3}.

# Arguments:
#
#    {0} = error
#
08001.C.3=Exception SocketException : ''{0}''

# Arguments:
#
#    {0} = error
#
08001.C.4=Impossible d''ouvrir le flux sur le socket : ''{0}''.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08001.C.5=La longueur de l''ID utilisateur ({0}) se situe hors de la plage comprise entre 1 et {1}.

# Arguments:
#
#    {0} = length
#    {1} = number
#
08001.C.6=La longueur du mot de passe ({0}) se situe hors de la plage comprise entre 1 et {1}.

08001.C.7=L''ID utilisateur ne peut pas \u00EAtre NULL.

08001.C.8=Le mot de passe ne peut pas \u00EAtre NULL.

# Arguments:
#
#    {0} = databaseName
#
08001.C.9=Aucune connexion n''a pu \u00EAtre \u00E9tablie car le nom de la base de donn\u00E9es ''{0}'' est plus grand que la longueur maximale autoris\u00E9e par le protocole r\u00E9seau.

08003=Aucune connexion en cours.

08003.C.1=getConnection() n''est pas valide sur un \u00E9l\u00E9ment PooledConnection ferm\u00E9.

08003.C.2=Appel de m\u00E9thode LOB apr\u00E8s fermeture de la connexion

08003.C.3=La connexion physique sous-jacente est obsol\u00E8te ou ferm\u00E9e.

# Arguments:
#
#    {0} = connectionName
#
08004=Connexion refus\u00E9e : {0}

# Arguments:
#
#    {0} = reasonText
#
08004.C.1=Echec de l''authentification de la connexion. Cause : {0}.

# Arguments:
#
#    {0} = databaseName
#
08004.C.2=La connexion a \u00E9t\u00E9 refus\u00E9e car la base de donn\u00E9es {0} est introuvable.

08004.C.3=Connexion \u00E0 la base de donn\u00E9es refus\u00E9e.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.4=L''utilisateur ''{0}'' ne peut pas arr\u00EAter la base de donn\u00E9es ''{1}''. Seul le propri\u00E9taire de la base de donn\u00E9es peut effectuer cette op\u00E9ration.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.5=L''utilisateur ''{0}'' ne peut pas (re)crypter la base de donn\u00E9es ''{1}''. Seul le propri\u00E9taire de la base de donn\u00E9es peut effectuer cette op\u00E9ration.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.6=L''utilisateur ''{0}'' ne peut pas effectuer une mise \u00E0 niveau mat\u00E9rielle de la base de donn\u00E9es ''{1}''. Seul le propri\u00E9taire de la base de donn\u00E9es peut effectuer cette op\u00E9ration.

# Arguments:
#
#    {0} = databaseName
#
08004.C.7=La connexion \u00E0 la base de donn\u00E9es ''{0}'' a \u00E9t\u00E9 refus\u00E9e, car celle-ci est en mode esclave de r\u00E9plication.

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#
08004.C.8=L''utilisateur ''{0}'' ne peut pas \u00E9mettre une op\u00E9ration de r\u00E9plication sur la base de donn\u00E9es  ''{1}''. Seul le propri\u00E9taire de la base de donn\u00E9es peut effectuer cette op\u00E9ration.

# Arguments:
#
#    {0} = authorizationID
#    {1} = exceptionMsg
#
08004.C.9=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s requis pour arr\u00EAter le syst\u00E8me [{1}].

# Arguments:
#
#    {0} = databaseName
#    {1} = exceptionMsg
#
08004.C.10=Impossible de v\u00E9rifier les droits d''acc\u00E8s syst\u00E8me pour cr\u00E9er la base de donn\u00E9es ''{0}'' [{1}].

# Arguments:
#
#    {0} = authorizationID
#    {1} = databaseName
#    {2} = exceptionMsg
#
08004.C.11=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s requis pour cr\u00E9er la base de donn\u00E9es ''{1}'' [{2}].

08004.C.12=Echec de l''authentification de la connexion. Les informations d''identification et de connexion fournies ne sont pas valides ou la base de donn\u00E9es utilise un mod\u00E8le de cryptage de mot de passe non compatible avec le m\u00E9canisme de s\u00E9curit\u00E9 renforc\u00E9 de substitution des mots de passe. Si cette erreur s''est produite \u00E0 la suite de la mise \u00E0 niveau, reportez-vous \u00E0 la note sur la version relative \u00E0 DERBY-4483 pour consulter les options disponibles.

08004.C.13=Le nom utilisateur ou le mot de passe est NULL ou de longueur 0.

# Arguments:
#
#    {0} = error
#
08006.C=Une erreur de protocole r\u00E9seau s''est produite et la connexion a \u00E9t\u00E9 ferm\u00E9e : {0}

08006.C.1=Une erreur s''est produite au cours de la r\u00E9initialisation de la connexion et la connexion a \u00E9t\u00E9 arr\u00EAt\u00E9e. Pour plus d''informations, consultez les exceptions cha\u00EEn\u00E9es.

# Arguments:
#
#    {0} = error
#
08006.C.2= Exception SocketException : ''{0}''

# Arguments:
#
#    {0} = error
#
08006.C.3=Une erreur de communication a \u00E9t\u00E9 d\u00E9tect\u00E9e : {0}.

08006.C.4=Une erreur s''est produite au cours d''une r\u00E9initialisation de connexion diff\u00E9r\u00E9e et la connexion a \u00E9t\u00E9 interrompue. Pour plus d''informations, consultez les exceptions cha\u00EEn\u00E9es.

# Arguments:
#
#    {0} = number
#    {1} = number
#
08006.C.5=Donn\u00E9es insuffisantes lors de la lecture depuis le r\u00E9seau : {0} octets \u00E9taient attendus, mais seulement {1} octets ont \u00E9t\u00E9 re\u00E7us. La connexion a \u00E9t\u00E9 interrompue.

08006.C.6=Tentative de mat\u00E9rialisation totale de donn\u00E9es LOB trop importantes pour la JVM. La connexion a \u00E9t\u00E9 interrompue.

08006.C.8=org.apache.derby.jdbc.EmbeddedDriver n''est pas inscrit aupr\u00E8s du gestionnaire de pilotes JDBC.

# Arguments:
#
#    {0} = databaseName
#
08006.D=Arr\u00EAt de la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = databaseName
#
08006.D.1=Base de donn\u00E9es ''{0}'' supprim\u00E9e.

# Arguments:
#
#    {0} = featureName
#
0A000.S=Fonctionnalit\u00E9 non impl\u00E9ment\u00E9e : {0}.

# Arguments:
#
#    {0} = commandName
#
0A000.C.6=La commande DRDA {0} n''est pas impl\u00E9ment\u00E9e actuellement. La connexion a \u00E9t\u00E9 interrompue.

0A000.S.1=La m\u00E9thode JDBC n''est pas encore impl\u00E9ment\u00E9e.

# Arguments:
#
#    {0} = methodName
#
0A000.S.2=La m\u00E9thode JDBC {0} n''est pas prise en charge par le serveur. Mettez le serveur \u00E0 niveau.

# Arguments:
#
#    {0} = propertyName
#
0A000.S.3=La propri\u00E9t\u00E9 resultSetHoldability {0} n''est pas prise en charge

0A000.S.4=La commande cancel() n''est pas prise en charge par le serveur.

# Arguments:
#
#    {0} = mechanismName
#
0A000.S.5=Le m\u00E9canisme de s\u00E9curit\u00E9 ''{0}'' n''est pas pris en charge.

# Arguments:
#
#    {0} = datatypeName
#
0A000.S.7=Le type de donn\u00E9es ''{0}'' n''est pas pris en charge.

# Arguments:
#
#    {0} = roleName
#
0P000=Sp\u00E9cification de r\u00F4le non valide, le r\u00F4le n''existe pas : ''{0}''.

# Arguments:
#
#    {0} = roleName
#
0P000.S.1=Sp\u00E9cification de r\u00F4le non valide, r\u00F4le non attribu\u00E9 \u00E0 l''utilisateur en cours ou PUBLIC : ''{0}''.

21000=Une sous-requ\u00EAte scalaire n''est autoris\u00E9e que pour renvoyer une seule ligne.

# Arguments:
#
#    {0} = dataType
#    {1} = dataValue
#    {2} = length
#
22001=Une erreur de troncature a \u00E9t\u00E9 d\u00E9tect\u00E9e lors de la tentative de r\u00E9duction de {0} ''{1}'' \u00E0 une longueur de {2}.

# Arguments:
#
#    {0} = datatypeName
#
22003=La valeur r\u00E9sultante se situe hors de la plage autoris\u00E9e pour le type de donn\u00E9es {0}.

# Arguments:
#
#    {0} = year
#    {1} = year
#
22003.S.1=L''ann\u00E9e ({0}) d\u00E9passe la valeur maximale ''{1}''.

22003.S.2=Les nombres d\u00E9cimaux ne peuvent comporter que 31 d\u00E9cimales maximum.

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22003.S.3=Un d\u00E9bordement s''est produit au cours de la conversion du type de donn\u00E9es num\u00E9riques de ''{0}'' vers {1}.

# Arguments:
#
#    {0} = number
#    {1} = datatypeName
#
22003.S.4=La longueur ({0}) d\u00E9passe la longueur maximale ({1}) autoris\u00E9e pour le type de donn\u00E9es.

# Arguments:
#
#    {0} = typeName
#    {1} = typeName
#
22005.S.1=Impossible de convertir une valeur de type ''{0}'' vers le type ''{1}'' : le codage n''est pas pris en charge.

22005.S.2=Le convertisseur de caract\u00E8res requis n''est pas disponible.

22005.S.3=Impossible de convertir une cha\u00EEne Unicode en cha\u00EEne Ebcdic

# Arguments:
#
#    {0} = typeName
#    {1} = number
#    {2} = number
#
22005.S.4=Type JDBC non reconnu. Type : {0}, columnCount : {1}, columnIndex : {2}.

# Arguments:
#
#    {0} = parameterName
#
22005.S.5=Type JDBC non valide pour le param\u00E8tre {0}.

# Arguments:
#
#    {0} = datatypeName
#
22005.S.6=Type de langage SQL Java {0} non reconnu.

22005.S.7=Impossible de convertir une cha\u00EEne Unicode en cha\u00EEne UTF-8

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
22005=Une tentative d''obtention d''une valeur de donn\u00E9es de type ''{0}'' \u00E0 partir d''une valeur de donn\u00E9es de type ''{1}'' a \u00E9t\u00E9 effectu\u00E9e.

22007.S.180=La repr\u00E9sentation de cha\u00EEne d''une valeur date/heure se situe hors de la plage autoris\u00E9e.

22007.S.181=La syntaxe de la repr\u00E9sentation de cha\u00EEne d''une valeur date/heure n''est pas correcte.

# Arguments:
#
#    {0} = argument
#    {1} = functionName
#
22008.S=''{0}'' est un argument non valide pour la fonction {1}.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
2200H.S=Le g\u00E9n\u00E9rateur de s\u00E9quence ''{0}.{1}'' ne fonctionne pas. Aucune autre valeur ne peut \u00EAtre obtenue de ce g\u00E9n\u00E9rateur de s\u00E9quence.

2200L=Les valeurs affect\u00E9es aux colonnes XML doivent \u00EAtre des noeuds de document au format correct.

# Arguments:
#
#    {0} = parserError
#
2200M=Document XML non valide : {0}

# Arguments:
#
#    {0} = operatorName
#
2200V=El\u00E9ment contextuel non valide pour l''op\u00E9rateur {0} ; les \u00E9l\u00E9ments contextuels doivent \u00EAtre des noeuds de document au format correct.

2200W=Erreur de s\u00E9rialisation XQuery : tentative de s\u00E9rialisation de noeuds d''attribut de niveau sup\u00E9rieur.

22011=Le deuxi\u00E8me ou troisi\u00E8me argument de la fonction SUBSTR se situe hors de la plage autoris\u00E9e.

# Arguments:
#
#    {0} = offset
#    {1} = len
#    {2} = str
#
22011.S.1=La plage sp\u00E9cifi\u00E9e pour la sous-cha\u00EEne avec la position {0} et la longueur {1} est hors plage pour la cha\u00EEne : {2}.

22012=Tentative de division par z\u00E9ro.

# Arguments:
#
#    {0} = number
#
22013=Tentative d''utilisation de la racine carr\u00E9e du nombre n\u00E9gatif ''{0}''.

# Arguments:
#
#    {0} = searchString
#    {1} = fromString
#    {2} = startIndex
#
22014=La position de d\u00E9but pour LOCATE n''est pas valide ; cette valeur doit \u00EAtre un entier positif. L''index \u00E0 partir duquel la recherche doit commencer est ''{2}''. La cha\u00EEne \u00E0 rechercher est ''{0}''. La cha\u00EEne dans laquelle effectuer la recherche est ''{1}''. 

# Arguments:
#
#    {0} = functionName
#    {1} = typeName
#    {2} = typeName
#    {3} = typeName
#
22015=La fonction ''{0}'' n''est pas autoris\u00E9e sur l''ensemble de types suivant. Le premier op\u00E9rande est de type ''{1}''. Le deuxi\u00E8me op\u00E9rande est de type ''{2}''. Le troisi\u00E8me op\u00E9rande (position de d\u00E9but) est de type ''{3}''.

# Arguments:
#
#    {0} = typeName
#
22018=Le format de la cha\u00EEne de caract\u00E8res n''est pas valide pour le type {0}.

# Arguments:
#
#    {0} = sequenceName
#
22019=S\u00E9quence d''\u00E9chappement non valide, ''{0}''. Cette cha\u00EEne doit comporter un seul caract\u00E8re. Elle ne doit pas avoir la valeur NULL ni comporter plusieurs caract\u00E8res.

# Arguments:
#
#    {0} = string
#
22020=Cha\u00EEne de troncature ''{0}'' non valide. Elle doit comprendre un seul caract\u00E8re ou \u00EAtre NULL. Elle ne doit pas compter plus d''un caract\u00E8re.

22025=Le caract\u00E8re d''\u00E9chappement doit \u00EAtre suivi d''un caract\u00E8re d''\u00E9chappement, ''_'' ou ''%''. Il ne peut \u00EAtre suivi d''aucun autre caract\u00E8re, ni se trouver \u00E0 la fin du mod\u00E8le.

22027=La fonction TRIM() int\u00E9gr\u00E9e prend en charge un seul caract\u00E8re de troncature. Les fonctions int\u00E9gr\u00E9es LTRIM() et RTRIM() prennent en charge plusieurs caract\u00E8res de troncature.

# Arguments:
#
#    {0} = number
#
22028=La cha\u00EEne d\u00E9passe la longueur maximale de {0}.

22501=Une clause ESCAPE ayant pour valeur NULL renvoie des r\u00E9sultats non d\u00E9finis et n''est pas autoris\u00E9e.

2201X=Nombre de lignes non valide pour OFFSET. Il doit \u00EAtre >= 0.

2201W=Le nombre de lignes pour FIRST/NEXT doit \u00EAtre >= 1 et le nombre de lignes pour LIMIT doit \u00EAtre >= 0.

# Arguments:
#
#    {0} = string
#
2201Z=La valeur NULL n''est pas autoris\u00E9e pour l''argument {0}.

# Arguments:
#
#    {0} = columnName
#
23502=La colonne ''{0}'' ne peut pas accepter la valeur NULL.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = statementType
#    {3} = keyName
#
23503={2} sur la table ''{1}'' a entra\u00EEn\u00E9 la violation de la contrainte de cl\u00E9 \u00E9trang\u00E8re ''{0}'' pour la cl\u00E9 {3}. L''instruction a \u00E9t\u00E9 annul\u00E9e (rollback).

# Arguments:
#
#    {0} = indexOrConstraintName
#    {1} = tableName
#
23505=L''instruction a \u00E9t\u00E9 abandonn\u00E9e car elle aurait entra\u00EEn\u00E9 une valeur de cl\u00E9 en double dans une contrainte de cl\u00E9 primaire ou unique, ou un index unique identifi\u00E9 par ''{0}'' d\u00E9fini sur ''{1}''.

# Arguments:
#
#    {0} = tableName
#    {1} = constraintName
#
23513=La contrainte CHECK ''{1}'' a \u00E9t\u00E9 viol\u00E9e au cours de l''ex\u00E9cution d''une op\u00E9ration INSERT ou UPDATE sur la table ''{0}''.

24000=Etat du curseur non valide. Aucune ligne en cours.

24501.S=Le curseur identifi\u00E9 n''est pas ouvert.

25001=Impossible de fermer une connexion pendant qu''une transaction est toujours active.

25001.S.1=Etat de transaction non valide : transaction SQL active.

25501=Impossible de d\u00E9finir la propri\u00E9t\u00E9 en lecture seule de la connexion dans une transaction active.

25502=La modification des donn\u00E9es SQL n''est pas autoris\u00E9e pour une connexion, un utilisateur ou une base de donn\u00E9es en lecture seule.

25503=Le DDL n''est pas autoris\u00E9 pour une connexion, un utilisateur ou une base de donn\u00E9es en lecture seule.

25505=Un utilisateur en lecture seule ou un utilisateur dans une base de donn\u00E9es en lecture seule n''est pas autoris\u00E9 \u00E0 d\u00E9sactiver le mode lecture seule sur une connexion.

# Arguments:
#
#    {0} = authorizationID
#
28502=Le nom utilisateur ''{0}'' n''est pas valide. 

2D521.S.1=Commande setAutoCommit(true) non valide au cours de la transaction globale.

2D521.S.2=Validation (commit) ou annulation (rollback) non valide pour l''environnement d''ex\u00E9cution de l''application. 

# Arguments:
#
#    {0} = exception
#
38000=L''exception ''{0}'' a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e lors de l''\u00E9valuation d''une expression.

38001=Le sous-programme externe n''est pas autoris\u00E9 \u00E0 ex\u00E9cuter des instructions SQL.

38002=Le sous-programme a tent\u00E9 de modifier des donn\u00E9es, mais il n''a pas \u00E9t\u00E9 d\u00E9fini en tant que MODIFIES SQL DATA.

38004=Le sous-programme a tent\u00E9 de lire des donn\u00E9es, mais il n''a pas \u00E9t\u00E9 d\u00E9fini en tant que READS SQL DATA.

# Arguments:
#
#    {0} = type
#
39004=La valeur NULL ne peut pas \u00EAtre transmise \u00E0 une m\u00E9thode qui accepte un param\u00E8tre de type primitif ''{0}''.

# Arguments:
#
#    {0} = savepointName
#
3B001.S=L''\u00E9l\u00E9ment SAVEPOINT {0} n''existe pas ou n''est pas actif dans la transaction en cours.

3B002.S=Le nombre maximal de points de sauvegarde a \u00E9t\u00E9 atteint. 

3B501.S=Un \u00E9l\u00E9ment SAVEPOINT portant le nom transmis existe d\u00E9j\u00E0 dans la transaction en cours.

3B502.S=Une lib\u00E9ration ou une annulation (rollback) jusqu''au point de sauvegarde a \u00E9t\u00E9 indiqu\u00E9e mais le point de sauvegarde n''existe pas.

# Arguments:
#
#    {0} = lockCycle
#    {1} = transactionID
#
40001=Impossible d''obtenir un verrou en raison d''un interblocage. Le cycle de verrous et de processus en attente est :\n{0}. La victime s\u00E9lectionn\u00E9e est le XID : {1}.

40XC0=Instruction supprim\u00E9e. Cela peut \u00EAtre d\u00FB \u00E0 une erreur de gravit\u00E9 de transaction dans cette instruction.

40XD0=Le conteneur a \u00E9t\u00E9 ferm\u00E9.

40XD1=Le conteneur a \u00E9t\u00E9 ouvert en mode lecture seule.

# Arguments:
#
#    {0} = containerName
#
40XD2=Impossible d''ouvrir le conteneur {0} ; soit il a \u00E9t\u00E9 supprim\u00E9, soit il n''existe pas.

40XL1=Impossible d''obtenir un verrou dans le d\u00E9lai demand\u00E9

# Arguments:
#
#    {0} = tableDump
#
40XL1.T.1=Impossible d''obtenir un verrou dans le d\u00E9lai demand\u00E9. Vidage lockTable : {0}

40XT0=Une erreur interne a \u00E9t\u00E9 identifi\u00E9e par le module RawStore.

40XT1=Une exception a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e au cours de la validation (commit) de la transaction.

40XT2=Une exception a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e au cours de l''annulation (rollback) d''un \u00E9l\u00E9ment SAVEPOINT.

40XT4=Une tentative de fermeture d''une transaction toujours active a \u00E9t\u00E9 effectu\u00E9e. La transaction a \u00E9t\u00E9 abandonn\u00E9e.

40XT5=Une exception a \u00E9t\u00E9 \u00E9mise au cours d''une transaction interne.

40XT6=La base de donn\u00E9es est en \u00E9tat inactif ; impossible d''activer la transaction. Veuillez patienter jusqu''\u00E0 ce qu''elle quitte cet \u00E9tat.

40XT7=Op\u00E9ration non prise en charge dans une transaction interne.

42000=Erreur de syntaxe ou violation des r\u00E8gles d''acc\u00E8s ; pour plus de d\u00E9tails, consultez les autres erreurs.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42500=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur la table ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = schemaNamet
#    {3} = tableName
#
42501=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur la table ''{2}''.''{3}'' pour l''octroi.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42502=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur la colonne ''{2}'' de la table ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = columnName
#    {3} = schemaName
#    {4} = tableName
#
42503=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur la colonne ''{2}'' de la table ''{3}''.''{4}'' pour l''octroi.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42504=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur {2} ''{3}''.''{4}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionType
#    {2} = objectName
#    {3} = schemaName
#    {4} = tableName
#
42505=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur {2} ''{3}''.''{4}'' pour l''octroi.

# Arguments:
#
#    {0} = authorizationID
#    {1} = objectName
#    {2} = schemaName
#    {3} = tableName
#
42506=L''utilisateur ''{0}'' n''est pas propri\u00E9taire de {1} ''{2}''.''{3}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42507=L''utilisateur ''{0}'' ne peut pas ex\u00E9cuter l''op\u00E9ration dans le sch\u00E9ma ''{1}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = schemaName
#
42508=L''utilisateur ''{0}'' ne peut pas cr\u00E9er le sch\u00E9ma ''{1}''. Seul le propri\u00E9taire de la base de donn\u00E9es peut \u00E9mettre cette instruction.

# Arguments:
#
#    {0} = objectName
#
42509=L''op\u00E9ration d''octroi ou de r\u00E9vocation sp\u00E9cifi\u00E9e n''est pas autoris\u00E9e sur l''objet ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#    {1} = permissionName
#    {2} = schemaName
#    {3} = objectName
#
4250A=L''utilisateur ''{0}'' ne dispose pas des droits d''acc\u00E8s {1} sur l''objet ''{2}''.''{3}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
4250B=Propri\u00E9t\u00E9 d''autorisation de base de donn\u00E9es non valide ''{0}={1}''.

# Arguments:
#
#    {0} = authorizationID
#
4250C=Les utilisateurs ''{0}'' ne doivent pas figurer \u00E0 la fois dans les listes d''autorisation d''acc\u00E8s en lecture seule et d''acc\u00E8s complet.

# Arguments:
#
#    {0} = listName
#    {1} = authorizationID
#
4250D=Utilisateurs r\u00E9p\u00E9t\u00E9s ''{1}'' dans la liste d''acc\u00E8s ''{0}'' ;

# Arguments:
#
#    {0} = authorizationID
#
4250E=Erreur interne : ID {0} non valide dans la liste des droits d''acc\u00E8s des instructions.

# Arguments:
#
#    {0} = sqlText
#
4251A=L''instruction {0} peut \u00EAtre \u00E9mise uniquement par le propri\u00E9taire de la base de donn\u00E9es.

4251B=L''\u00E9l\u00E9ment PUBLIC est r\u00E9serv\u00E9 et ne peut pas \u00EAtre utilis\u00E9 comme identificateur d''utilisateur ou nom de r\u00F4le.

# Arguments:
#
#    {0} = authorizationID
#    {1} = authorizationID
#
4251C=Le r\u00F4le {0} ne peut pas \u00EAtre accord\u00E9 \u00E0 {1}, car cela cr\u00E9erait une circularit\u00E9.

4251D=Seul le propri\u00E9taire de la base de donn\u00E9es peut effectuer cette op\u00E9ration.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
4251E=Personne ne peut visualiser la colonne ''{0}''.''{1}''.

4251F=Vous ne pouvez pas supprimer les informations d''identification et de connexion du propri\u00E9taire de la base de donn\u00E9es.

4251G=D\u00E9finissez derby.authentication.builtin.algorithm sur un algorithme de message Digest valide. Le mod\u00E8le d''authentification en cours est trop faible pour \u00EAtre utilis\u00E9 par l''authentification NATIVE.

4251H=Sp\u00E9cification de l''authentification NATIVE non valide. D\u00E9finissez derby.authentication.provider sur une valeur au format NATIVE:$credentialsDB ou NATIVE:$credentialsDB:LOCAL (au niveau syst\u00E8me).

# Arguments:
#
#    {0} = databaseName
#
4251I=Impossible d''effectuer l''authentification car la base de donn\u00E9es d''informations d''identification et de connexion ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = propertyName
#
4251J=Le format de la valeur de la propri\u00E9t\u00E9 ''{0}'' est incorrect.

4251K=Les premi\u00E8res informations d''identification et de connexion cr\u00E9\u00E9es doivent \u00EAtre celles du propri\u00E9taire de la base de donn\u00E9es.

# Arguments:
#
#    {0} = dbName
#
4251L=La propri\u00E9t\u00E9 derby.authentication.provider sp\u00E9cifie ''{0}'' en tant que nom de la base de donn\u00E9es d''informations d''identification et de connexion. Ce nom n''est pas valide pour une base de donn\u00E9es.

# Arguments:
#
#    {0} = columnName
#
42601=Dans une instruction ALTER TABLE, la colonne ''{0}'' a \u00E9t\u00E9 sp\u00E9cifi\u00E9e en tant que NOT NULL et la clause DEFAULT n''a pas \u00E9t\u00E9 sp\u00E9cifi\u00E9e ou a \u00E9t\u00E9 sp\u00E9cifi\u00E9e en tant que DEFAULT NULL.

42601.S.372=L''instruction ALTER TABLE ne peut pas ajouter une colonne IDENTITY \u00E0 la table.

# Arguments:
#
#    {0} = functionName
#
42605=Le nombre d''arguments pour la fonction ''{0}'' n''est pas valide.

# Arguments:
#
#    {0} = number
#
42606=Une constante hexad\u00E9cimale non valide commen\u00E7ant par ''{0}'' a \u00E9t\u00E9 d\u00E9tect\u00E9e.

42610=Les arguments de la fonction COALESCE/VALUE ne peuvent pas tous \u00EAtre des param\u00E8tres. La fonction doit disposer d''au moins un argument qui n''est pas un param\u00E8tre.

# Arguments:
#
#    {0} = dataType
#
42611=L''attribut de longueur, de pr\u00E9cision ou d''\u00E9chelle de la colonne ou le mapping de type ''{0}'' n''est pas valide. 

# Arguments:
#
#    {0} = clause
#
42613=Pr\u00E9sence de mots cl\u00E9s multiples ou incompatibles impliquant la clause ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42621=Une contrainte CHECK ou une colonne g\u00E9n\u00E9r\u00E9e d\u00E9finie avec ''{0}'' n''est pas valide.

# Arguments:
#
#    {0} = name
#    {1} = number
#
42622=Le nom ''{0}'' est trop long. La longueur maximale est ''{1}''.

# Arguments:
#
#    {0} = name
#    {1} = context
#
42734=Le nom ''{0}'' indiqu\u00E9 dans le contexte ''{1}'' n''est pas unique.

42802=Le nombre de valeurs affect\u00E9es n''est pas le m\u00EAme que le nombre de colonnes sp\u00E9cifi\u00E9es ou implicites.

# Arguments:
#
#    {0} = columnName
#
42803=Une expression contenant la colonne ''{0}'' appara\u00EEt dans la liste SELECT et ne fait pas partie d''une clause GROUP BY.

# Arguments:
#
#    {0} = sqlText
#
42815.S.713=La valeur de remplacement de ''{0}'' n''est pas valide.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#
42815.S.171=Les types de donn\u00E9es, les longueurs ou les valeurs des arguments ''{0}'' et ''{1}'' sont incompatibles.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42818=Les comparaisons entre ''{0}'' et ''{1}'' ne sont pas prises en charge. Les types doivent \u00EAtre comparables. Les types de cha\u00EEne doivent \u00E9galement disposer d''un classement correspondant. Si le classement ne correspond pas, l''une des solutions consiste \u00E0 forcer des op\u00E9randes \u00E0 appliquer le classement par d\u00E9faut (par ex., SELECT tablename FROM sys.systables WHERE CAST(tablename AS VARCHAR(128)) = ''T1'').

# Arguments:
#
#    {0} = string
#
42820=Le litt\u00E9ral \u00E0 virgule flottante ''{0}'' contient plus de 30 caract\u00E8res.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42821=Les colonnes de type ''{0}'' ne peuvent pas contenir de valeurs de type ''{1}''. 

42824=Un op\u00E9rande de LIKE n''est pas une cha\u00EEne ou le premier op\u00E9rande n''est pas une colonne.

# Arguments:
#
#    {0} = columnName
#
42831=''{0}'' ne peut pas \u00EAtre une colonne de cl\u00E9 primaire ou unique car elle peut contenir des valeurs NULL.

# Arguments:
#
#    {0} = columnName
#
42831.S.1=''{0}'' ne peut pas \u00EAtre une colonne de cl\u00E9 primaire car elle peut contenir des valeurs NULL.

# Arguments:
#
#    {0} = key
#
42834=SET NULL ne peut \u00EAtre indiqu\u00E9 car l''\u00E9l\u00E9ment FOREIGN KEY ''{0}'' ne peut pas contenir de valeurs NULL.  

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42837=ALTER TABLE ''{0}'' a indiqu\u00E9 des attributs pour la colonne ''{1}'' qui ne sont pas compatibles avec la colonne existante.

# Arguments:
#
#    {0} = type
#    {1} = type
#
42846=Impossible de convertir les types ''{0}'' vers ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42877=Le nom de colonne qualifi\u00E9 ''{0}'' n''est pas autoris\u00E9 dans la clause ORDER BY.

42878=La clause ORDER BY d''une instruction SELECT UNION prend uniquement en charge les r\u00E9f\u00E9rences de colonne non qualifi\u00E9es et les num\u00E9ros de position des colonnes. Les autres expressions ne sont pas prises en charge pour l''instant.

# Arguments:
#
#    {0} = columnName
#
42879=La clause ORDER BY peut ne pas contenir la colonne ''{0}'', car la requ\u00EAte indique DISTINCT et cette colonne ne figure pas dans les r\u00E9sultats de la requ\u00EAte.

4287A=La clause ORDER BY peut ne pas sp\u00E9cifier d''expression, car la requ\u00EAte indique DISTINCT.

# Arguments:
#
#    {0} = routineName
#    {1} = type
#
42884=Aucun sous-programme non autoris\u00E9 nomm\u00E9 ''{0}'' de type ''{1}'' et comportant des arguments compatibles n''a \u00E9t\u00E9 trouv\u00E9.

# Arguments:
#
#    {0} = parameterMode
#    {1} = parameterName
#
42886=Le param\u00E8tre ''{0}'' ''{1}'' exige un marqueur de param\u00E8tre ''?''.

# Arguments:
#
#    {0} = columnName
#
42894=La valeur DEFAULT ou la valeur d''attribut IDENTITY n''est pas valide pour la colonne ''{0}''.

428C1=Une seule colonne d''identit\u00E9 est autoris\u00E9e dans une table.

428EK=Le qualificatif d''un nom de table temporaire globale d\u00E9clar\u00E9e doit \u00EAtre SESSION.

42903=Utilisation non valide d''une fonction d''agr\u00E9gation.

42908=L''instruction CREATE VIEW n''inclut pas de liste de colonnes.

42909=L''instruction CREATE TABLE ne comprend pas de liste de colonnes.

# Arguments:
#
#    {0} = key
#    {1} = detailedReason
#
42915=La cl\u00E9 \u00E9trang\u00E8re ''{0}'' n''est pas valide pour la raison suivante : ''{1}''. 

# Arguments:
#
#    {0} = synonym2
#    {1} = synonym1
#
42916=Impossible de cr\u00E9er le synonyme ''{0}'' pour ''{1}'' car cette action g\u00E9n\u00E8re une cha\u00EEne de synonymes circulaire.

# Arguments:
#
#    {0} = schemaNamet
#
42939=Impossible de cr\u00E9er un objet avec le nom du sch\u00E9ma ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#
4293A=Impossible de cr\u00E9er un r\u00F4le avec le nom ''{0}'' ; le pr\u00E9fixe SYS est r\u00E9serv\u00E9.

# Arguments:
#
#    {0} = columnName
#
42962=La colonne de type Long ou le param\u00E8tre ''{0}'' n''est pas autoris\u00E9 dans des tables temporaires globales d\u00E9clar\u00E9es ou des d\u00E9finitions de proc\u00E9dure. 

42995=La fonction demand\u00E9e ne s''applique pas aux tables temporaires globales.

# Arguments:
#
#    {0} = error
#
42X01=Erreur de syntaxe : {0}.

# Arguments:
#
#    {0} = parserException
#
42X02={0}.

# Arguments:
#
#    {0} = columnName
#
42X03=Le nom de colonne ''{0}'' se trouve dans plusieurs tables de la liste FROM.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42X04=La colonne ''{0}'' ne se trouve dans aucune table de la liste FROM, figure dans une sp\u00E9cification de jointure et se trouve en dehors de la port\u00E9e de cette sp\u00E9cification, ou figure dans une clause HAVING mais ne se trouve pas dans la liste GROUP BY. S''il s''agit d''une instruction CREATE ou ALTER TABLE, ''{0}'' n''est pas une colonne de la table cible.

# Arguments:
#
#    {0} = objectName
#
42X05=La table/vue ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = tableName
#
42X06=Nombre de colonnes de r\u00E9sultats sp\u00E9cifi\u00E9 trop \u00E9lev\u00E9 pour la table ''{0}''.

42X07=La valeur NULL est uniquement autoris\u00E9e dans une clause VALUES au sein d''une instruction INSERT.

# Arguments:
#
#    {0} = className
#    {1} = constructorName
#
42X08=Le constructeur de la classe ''{0}'' ne peut pas \u00EAtre utilis\u00E9 en tant que table virtuelle externe car la classe n''impl\u00E9mente pas ''{1}''. 

# Arguments:
#
#    {0} = tableName
#
42X09=Le nom de table ou d''alias ''{0}'' est utilis\u00E9 plusieurs fois dans la liste FROM.

# Arguments:
#
#    {0} = tableName
#
42X10=''{0}'' n''est pas un nom de table expos\u00E9 dans la port\u00E9e o\u00F9 il figure.

# Arguments:
#
#    {0} = columnName
#
42X12=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction CREATE TABLE.  

# Arguments:
#
#    {0} = columnName
#
42X13=Le nom de colonne ''{0}'' figure plusieurs fois dans la liste des colonnes d''une instruction INSERT. 

# Arguments:
#
#    {0} = columnName
#    {1} = tableOrVTIName
#
42X14=''{0}'' n''est pas une colonne de la table ou de la VTI ''{1}''.

# Arguments:
#
#    {0} = columnName
#
42X15=Le nom de colonne ''{0}'' figure dans une instruction ne contenant aucune liste FROM.

# Arguments:
#
#    {0} = columnName
#
42X16=Le nom de colonne ''{0}'' figure plusieurs fois dans la clause SET d''une instruction UPDATE.

# Arguments:
#
#    {0} = joinOrder
#
42X17=Dans la liste Propri\u00E9t\u00E9s d''une clause FROM, la valeur ''{0}'' n''est pas valide en tant que sp\u00E9cification joinOrder. Seules les valeurs FIXED et UNFIXED sont valides.  

# Arguments:
#
#    {0} = dataType
#
42X19.S.1=La clause WHERE ou HAVING ou la d\u00E9finition CHECK CONSTRAINT est une expression ''{0}''. Il doit s''agir d''une expression bool\u00E9enne.

42X19.S.2=La clause WHERE ou HAVING ou la d\u00E9finition CHECK CONSTRAINT est une expression de param\u00E8tre sans type. Il faut que ce soit une expression bool\u00E9enne.

42X20=Erreur de syntaxe. Un litt\u00E9ral entier est attendu.

# Arguments:
#
#    {0} = cursorName
#
42X23=Le curseur {0} ne peut pas \u00EAtre mis \u00E0 jour.

# Arguments:
#
#    {0} = columnName
#
42X24=La colonne {0} est r\u00E9f\u00E9renc\u00E9e dans la clause HAVING, mais elle ne figure pas dans la liste GROUP BY.

# Arguments:
#
#    {0} = functionName
#    {1} = 1
#
42X25=La fonction ''{0}'' n''est pas autoris\u00E9e sur le type ''{1}''.

# Arguments:
#
#    {0} = className
#    {1} = columnName
#
42X26=La classe ''{0}'' de la colonne ''{1}'' n''existe pas ou est inaccessible. Cela peut se produire si la classe n''est pas publique.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X28=La table de suppression ''{0}'' n''est pas la cible du curseur ''{1}''.

# Arguments:
#
#    {0} = tableName
#    {1} = cursorName
#
42X29=La table de mise \u00E0 jour ''{0}'' n''est pas la cible du curseur ''{1}''.

# Arguments:
#
#    {0} = cursorName
#
42X30=Le curseur ''{0}'' est introuvable. V\u00E9rifiez que la fonction de validation automatique est d\u00E9sactiv\u00E9e.

# Arguments:
#
#    {0} = columnName
#    {1} = cursorName
#
42X31=La colonne ''{0}'' ne se trouve pas dans la liste FOR UPDATE du curseur ''{1}''.

# Arguments:
#
#    {0} = tableName
#
42X32=Le nombre de colonnes de la liste de colonnes d\u00E9riv\u00E9es doit correspondre au nombre de colonnes de la table ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42X33=La liste de colonnes d\u00E9riv\u00E9es contient le nom de colonne en double ''{0}''.

42X34=Il existe un param\u00E8tre ? dans la liste de s\u00E9lection. Ce param\u00E8tre n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = operatorName
#
42X35=Les deux op\u00E9randes de ''{0}'' ne peuvent pas \u00EAtre des param\u00E8tres ?.

# Arguments:
#
#    {0} = operatorName
#
42X36=L''op\u00E9rateur ''{0}'' ne peut pas utiliser un param\u00E8tre ? comme op\u00E9rande.

# Arguments:
#
#    {0} = operatorName
#    {1} = type
#
42X37=L''op\u00E9rateur unaire ''{0}'' n''est pas autoris\u00E9 sur le type ''{1}''.

42X38=''SELECT *'' est uniquement autoris\u00E9 dans les sous-requ\u00EAtes EXISTS et NOT EXISTS.

42X39=La sous-requ\u00EAte est uniquement autoris\u00E9e \u00E0 renvoyer une colonne unique.

42X40=Une instruction NOT comporte un op\u00E9rande qui n''est pas bool\u00E9en. L''op\u00E9rande de NOT doit avoir pour r\u00E9sultat TRUE, FALSE ou UNKNOWN. 

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
42X41=Dans la clause Propri\u00E9t\u00E9s d''une liste FROM, la propri\u00E9t\u00E9 ''{0}'' n''est pas valide (la propri\u00E9t\u00E9 a \u00E9t\u00E9 d\u00E9finie sur ''{1}''). 

# Arguments:
#
#    {0} = columnName
#
42X42=Le nom de corr\u00E9lation n''est pas autoris\u00E9 pour la colonne ''{0}'' car elle fait partie de la liste FOR UPDATE.

# Arguments:
#
#    {0} = className
#
42X43=L''\u00E9l\u00E9ment ResultSetMetaData renvoy\u00E9 pour la classe/l''objet ''{0}'' est NULL. L''\u00E9l\u00E9ment ResultSetMetaData doit \u00EAtre non NULL pour que cette classe puisse \u00EAtre utilis\u00E9e en tant que table virtuelle externe. 

# Arguments:
#
#    {0} = number
#
42X44=Longueur non valide ''{0}'' dans la sp\u00E9cification de colonne.

# Arguments:
#
#    {0} = dataType
#    {1} = argumentNumber
#    {2} = operatorName
#
42X45={0} est un type non valide pour le num\u00E9ro d''argument {1} de {2}.

# Arguments:
#
#    {0} = functionName
#
42X46=Il existe plusieurs fonctions nomm\u00E9es ''{0}''. Utilisez la signature compl\u00E8te ou le nom sp\u00E9cifique.

# Arguments:
#
#    {0} = procedureName
#
42X47=Il existe plusieurs proc\u00E9dures nomm\u00E9es ''{0}''. Utilisez la signature compl\u00E8te ou le nom sp\u00E9cifique.

# Arguments:
#
#    {0} = dataType
#    {1} = number
#
42X48=La valeur ''{1}'' n''est pas une pr\u00E9cision valide pour {0}.

# Arguments:
#
#    {0} = invalidNumber
#
42X49=La valeur ''{0}'' n''est pas un litt\u00E9ral entier valide.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X50=Aucune m\u00E9thode correspondant \u00E0 l''appel de m\u00E9thode {0}.{1}({2}) n''a \u00E9t\u00E9 trouv\u00E9e. Toutes les combinaisons de types d''objet et de types primitifs, ainsi que toutes les conversions de type possibles pour tous les param\u00E8tres que l''appel de m\u00E9thode pourrait contenir ont \u00E9t\u00E9 essay\u00E9es. La m\u00E9thode peut exister mais n''est pas publique ou statique, ou les types de param\u00E8tre ne peuvent pas \u00EAtre convertis en appel de m\u00E9thode.

# Arguments:
#
#    {0} = className
#
42X51=La classe ''{0}'' n''existe pas ou est inaccessible. Cela peut se produire si la classe n''est pas publique.

# Arguments:
#
#    {0} = methodName
#    {1} = type
#
42X52=L''appel de la m\u00E9thode (''{0}'') \u00E0 l''aide d''un r\u00E9cepteur du type primitif Java ''{1}'' n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = type
#
42X53=Le pr\u00E9dicat LIKE peut uniquement disposer des op\u00E9randes ''CHAR'' ou ''VARCHAR''. Le type ''{0}'' n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = methodName
#
42X54=La m\u00E9thode Java ''{0}'' dispose d''un param\u00E8tre ? en tant que r\u00E9cepteur, ce qui n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = tableName
#    {1} = tableName
#
42X55=Le nom de table ''{1}'' doit \u00EAtre le m\u00EAme que ''{0}''.

# Arguments:
#
#    {0} = viewName
#
42X56=Le nombre de colonnes de la liste des colonnes de vue doit correspondre au nombre de colonnes de l''expression de requ\u00EAte sous-jacente dans la d\u00E9finition de vue pour ''{0}''.

# Arguments:
#
#    {0} = tableName
#    {1} = number
#
42X57=La commande getColumnCount() pour la table virtuelle externe ''{0}'' a renvoy\u00E9 la valeur non valide ''{1}''. Les valeurs valides sont \u00E9gales ou sup\u00E9rieures \u00E0 1. 

# Arguments:
#
#    {0} = tableName
#
42X58=Le nombre de colonnes situ\u00E9es \u00E0 gauche et \u00E0 droite de l''\u00E9l\u00E9ment {0} doit \u00EAtre identique.

42X59=Le nombre de colonnes de chaque constructeur VALUES doit \u00EAtre le m\u00EAme.

# Arguments:
#
#    {0} = insertMode
#    {1} = tableName
#
42X60=Valeur non valide ''{0}'' pour la propri\u00E9t\u00E9 insertMode sp\u00E9cifi\u00E9e pour la table ''{1}''.

# Arguments:
#
#    {0} = dataType
#    {1} = dataType
#    {2} = sqlOperator
#
42X61=Les types ''{0}'' et ''{1}'' ne sont pas compatibles avec {2}.

# Arguments:
#
#    {0} = sqlText
#    {1} = schemaName
#
42X62=''{0}'' n''est pas autoris\u00E9 dans le sch\u00E9ma ''{1}''.

42X63=La clause USING n''a pas renvoy\u00E9 de r\u00E9sultats. Aucun param\u00E8tre ne peut \u00EAtre d\u00E9fini. 

# Arguments:
#
#    {0} = propertyValue
#
42X64=Dans la liste Propri\u00E9t\u00E9s, la valeur non valide ''{0}'' a \u00E9t\u00E9 indiqu\u00E9e pour la propri\u00E9t\u00E9 useStatistics. Les seules valeurs valides sont TRUE et FALSE. 

# Arguments:
#
#    {0} = index
#
42X65=L''index ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = columnName
#
42X66=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction CREATE INDEX.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X68=Aucun champ ''{0}'' appartenant \u00E0 la classe ''{1}'' n''a \u00E9t\u00E9 trouv\u00E9. Il est possible que ce champ existe, mais qu''il ne soit pas public, ou que la classe n''existe pas ou qu''elle ne soit pas publique.

# Arguments:
#
#    {0} = fieldName
#    {1} = type
#
42X69=Le r\u00E9f\u00E9rencement d''un champ (''{0}'') \u00E0 l''aide d''une expression de r\u00E9f\u00E9rencement du type primitif Java ''{1}'' n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = tableName
#
42X70=Le nombre de colonnes sp\u00E9cifi\u00E9 dans la liste de colonnes de la table ne correspond pas au nombre de colonnes indiqu\u00E9 dans l''expression de requ\u00EAte sous-jacente figurant dans la d\u00E9finition de table de ''{0}''.

# Arguments:
#
#    {0} = datatypeName
#    {1} = columnName
#
42X71=Type de donn\u00E9es ''{0}'' non valide pour la colonne ''{1}''.

# Arguments:
#
#    {0} = fieldName
#    {1} = className
#
42X72=Le champ statique ''{0}'' appartenant \u00E0 la classe ''{1}'' est introuvable. Il est possible que le champ existe mais qu''il ne soit pas public ou statique, ou que la classe n''existe pas ou ne soit pas publique.  

# Arguments:
#
#    {0} = className
#    {1} = methodName
#    {2} = parameterTypes
#
42X73=La r\u00E9solution de m\u00E9thode pour la signature {0}.{1}({2}) est ambigu\u00EB. (Aucune m\u00E9thode sp\u00E9cifique maximale unique.)

42X74=Syntaxe de l''instruction CALL non valide.

# Arguments:
#
#    {0} = className
#    {1} = parameterTypes
#
42X75=Aucun constructeur avec la signature {0}({1}) n''a \u00E9t\u00E9 trouv\u00E9. Il est possible que les types de param\u00E8tre ne puissent pas \u00EAtre convertis en appel de m\u00E9thode.

# Arguments:
#
#    {0} = columnName
#
42X76=Au moins une colonne, ''{0}'', de la cl\u00E9 primaire ajout\u00E9e peut \u00EAtre NULL. Aucune colonne de cl\u00E9 primaire ne peut \u00EAtre NULL.

# Arguments:
#
#    {0} = columnPosition
#
42X77=La position de la colonne ''{0}'' est en dehors des limites pour l''expression de requ\u00EAte.

# Arguments:
#
#    {0} = columnName
#
42X78=La colonne ''{0}'' ne figure pas dans les r\u00E9sultats de l''expression de requ\u00EAte.

# Arguments:
#
#    {0} = columnName
#
42X79=Le nom de colonne ''{0}'' figure plusieurs fois dans les r\u00E9sultats de l''expression de requ\u00EAte.

42X80=La clause VALUES doit contenir au moins un \u00E9l\u00E9ment. Les \u00E9l\u00E9ments vides ne sont pas autoris\u00E9s. 

42X81=Une expression de requ\u00EAte doit renvoyer au moins une colonne.

42X82=La clause USING a renvoy\u00E9 plusieurs lignes. Seuls les \u00E9l\u00E9ments ResultSets comportant une seule ligne sont autoris\u00E9s.

# Arguments:
#
#    {0} = index
#    {1} = constraintName
#
42X84=L''index ''{0}'' a \u00E9t\u00E9 cr\u00E9\u00E9 pour appliquer la contrainte ''{1}''. Il ne peut \u00EAtre supprim\u00E9 que par la suppression de la contrainte.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X85=La contrainte ''{0}'' doit se trouver dans le m\u00EAme sch\u00E9ma que la table ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42X86=Echec d''ALTER TABLE. Il n''existe aucune contrainte ''{0}'' sur la table ''{1}''. 

# Arguments:
#
#    {0} = expression
#
42X87=Au moins une expression de r\u00E9sultat (THEN ou ELSE) de l''expression ''{0}'' doit \u00EAtre diff\u00E9rente de ''?''. 

42X88=Un conditionnel comporte un op\u00E9rande non bool\u00E9en. L''op\u00E9rande d''un conditionnel doit avoir pour r\u00E9sultat TRUE, FALSE ou UNKNOWN.  

# Arguments:
#
#    {0} = type
#    {1} = type
#
42X89=Les types ''{0}'' et ''{1}'' ne sont pas compatibles. Aucun de ces deux types ne peut \u00EAtre affect\u00E9 \u00E0 l''autre.  

# Arguments:
#
#    {0} = tableName
#
42X90=Plusieurs contraintes de cl\u00E9 primaire sont indiqu\u00E9es pour la table ''{0}''.

# Arguments:
#
#    {0} = constraintName
#
42X91=Le nom de contrainte ''{0}'' figure plusieurs fois dans l''instruction CREATE TABLE. 

# Arguments:
#
#    {0} = columnName
#
42X92=Le nom de colonne ''{0}'' figure plusieurs fois dans la liste de colonnes d''une contrainte.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42X93=La table ''{0}'' contient une d\u00E9finition de contrainte avec la colonne ''{1}'', qui ne se trouve pas dans la table.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = objectName
#
42X94={0} ''{1}'' n''existe pas.

# Arguments:
#
#    {0} = fileName
#
42X96=Le chemin de classe de la base de donn\u00E9es contient un fichier JAR inconnu ''{0}''.

42X98=Les param\u00E8tres ne sont pas autoris\u00E9s dans une d\u00E9finition VIEW.

42X99=Les param\u00E8tres ne sont pas autoris\u00E9s dans une d\u00E9finition TABLE.

# Arguments:
#
#    {0} = columnName
#    {1} = datatypeName
#
42XA0=La clause de g\u00E9n\u00E9ration de la colonne ''{0}'' poss\u00E8de le type de donn\u00E9es ''{1}'', qui ne peut pas \u00EAtre affect\u00E9 au type de donn\u00E9es d\u00E9clar\u00E9 de la colonne.

# Arguments:
#
#    {0} = columnName
#
42XA1=La clause de g\u00E9n\u00E9ration de la colonne ''{0}'' contient un agr\u00E9gat. Ce n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = sqlObjectName
#
42XA2=''{0}'' ne peut pas figurer dans une clause de g\u00E9n\u00E9ration car il pourrait renvoyer des r\u00E9sultats peu fiables.

# Arguments:
#
#    {0} = columnName
#
42XA3=Vous ne pouvez pas remplacer la valeur de la colonne g\u00E9n\u00E9r\u00E9e ''{0}''.

# Arguments:
#
#    {0} = columnName
#
42XA4=La clause de g\u00E9n\u00E9ration de la colonne ''{0}'' r\u00E9f\u00E9rence d''autres colonnes g\u00E9n\u00E9r\u00E9es. Ce n''est pas autoris\u00E9.

# Arguments:
#
#    {0} = routineName
#
42XA5=Le sous-programme ''{0}'' peut \u00E9mettre des commandes SQL et ne peut donc pas appara\u00EEtre dans une clause de g\u00E9n\u00E9ration.

# Arguments:
#
#    {0} = columnName
#
42XA6=''{0}'' est une colonne g\u00E9n\u00E9r\u00E9e. Elle ne peut pas faire partie d''une cl\u00E9 \u00E9trang\u00E8re dont l''action r\u00E9f\u00E9rentielle pour DELETE est SET NULL ou SET DEFAULT ou dont l''action r\u00E9f\u00E9rentielle pour UPDATE est CASCADE.

# Arguments:
#
#    {0} = columnName
#
42XA7=''{0}'' est une colonne g\u00E9n\u00E9r\u00E9e. Vous ne pouvez pas modifier sa valeur par d\u00E9faut.

# Arguments:
#
#    {0} = columnName
#    {1} = columnName
#
42XA8=Vous ne pouvez pas renommer ''{0}'', car la clause de g\u00E9n\u00E9ration de la colonne ''{1}'' y fait r\u00E9f\u00E9rence.

# Arguments:
#
#    {0} = columnName
#
42XA9=La colonne ''{0}'' n\u00E9cessite un type de donn\u00E9es explicite. Vous pouvez omettre le type de donn\u00E9es uniquement pour les colonnes comportant des clauses de g\u00E9n\u00E9ration.

# Arguments:
#
#    {0} = columnName
#
42XAA=La valeur NEW de la colonne g\u00E9n\u00E9r\u00E9e ''{0}'' est mentionn\u00E9e dans l''action BEFORE d''un d\u00E9clencheur. Ce n''est pas autoris\u00E9.

42XAB=NOT NULL est autoris\u00E9 uniquement si vous d\u00E9clarez explicitement un type de donn\u00E9es.

42XAC=La valeur ''INCREMENT BY'' ne peut pas \u00EAtre z\u00E9ro.

# Arguments:
#
#    {0} = argName
#    {1} = datatypeName
#    {2} = minValue
#    {3} = maxValue
#
42XAE=La valeur ''{0}'' est hors limites pour le type de donn\u00E9es ''{1}''. Elle doit \u00EAtre comprise entre ''{2}'' et ''{3}''.

# Arguments:
#
#    {0} = minValue
#    {1} = maxValue
#
42XAF=Valeur ''MINVALUE'' ''{0}'' non valide. Doit \u00EAtre inf\u00E9rieure \u00E0 ''MAXVALUE : {1}''.

# Arguments:
#
#    {0} = startValue
#    {1} = minValue
#    {2} = maxValue
#
42XAG=Valeur ''START WITH'' ''{0}'' non valide. Elle doit \u00EAtre comprise entre ''{1}'' et ''{2}''.

42XAH=Une expression NEXT VALUE FOR peut ne pas appara\u00EEtre dans divers contextes, notamment dans les clauses WHERE, ON, HAVING, ORDER BY, DISTINCT, CASE, GENERATION et AGGREGATE, ainsi que dans les fonctions WINDOW et CHECK CONSTRAINTS.

# Arguments:
#
#    {0} = sequenceName
#
42XAI=L''instruction r\u00E9f\u00E9rence plusieurs fois la s\u00E9quence suivante : ''{0}''.

# Arguments:
#
#    {0} = clauseName
#
42XAJ=L''instruction CREATE SEQUENCE contient une clause ''{0}'' redondante.

# Arguments:
#
#    {0} = className
#
42Y00=La classe ''{0}'' n''impl\u00E9mente pas org.apache.derby.iapi.db.AggregateDefinition et ne peut donc pas \u00EAtre utilis\u00E9e en tant qu''expression d''agr\u00E9gation.

# Arguments:
#
#    {0} = constraintName
#
42Y01=La contrainte ''{0}'' n''est pas valide.

# Arguments:
#
#    {0} = statement
#
42Y03.S.0=''{0}'' n''est pas reconnu comme fonction ou proc\u00E9dure.

# Arguments:
#
#    {0} = statement
#
42Y03.S.1=''{0}'' n''est pas reconnu comme proc\u00E9dure.

# Arguments:
#
#    {0} = statement
#
42Y03.S.2=''{0}'' n''est pas reconnu comme fonction.

# Arguments:
#
#    {0} = name
#
42Y04=Impossible de cr\u00E9er une proc\u00E9dure ou une fonction avec un \u00E9l\u00E9ment EXTERNAL NAME \u00E9gal \u00E0 ''{0}'' car il ne s''agit pas d''une liste dont les \u00E9l\u00E9ments sont s\u00E9par\u00E9s par un point. Le format attendu est <chemin d''acc\u00E8s Java complet>.<nom de m\u00E9thode>.

# Arguments:
#
#    {0} = key
#
42Y05=Aucune cl\u00E9 \u00E9trang\u00E8re n''est nomm\u00E9e ''{0}''.

# Arguments:
#
#    {0} = schemaNamet
#
42Y07=Le sch\u00E9ma ''{0}'' n''existe pas

42Y08=Les contraintes de cl\u00E9 \u00E9trang\u00E8re ne sont pas autoris\u00E9es sur les tables syst\u00E8me.

42Y09=Les m\u00E9thodes void sont uniquement autoris\u00E9es dans une instruction CALL.

42Y10=Un constructeur de table qui ne figure pas dans une instruction INSERT poss\u00E8de tous les param\u00E8tres ? dans l''une de ses colonnes. Pour chaque colonne, au moins l''une des lignes doit contenir un \u00E9l\u00E9ment qui n''est pas un param\u00E8tre.

# Arguments:
#
#    {0} = clauseName
#
42Y11=Une sp\u00E9cification de jointure est requise avec la clause ''{0}''.

# Arguments:
#
#    {0} = expressionType
#
42Y12=La clause ON d''un \u00E9l\u00E9ment JOIN est une expression ''{0}''. Il doit s''agir d''une expression BOOLEAN.

# Arguments:
#
#    {0} = columnName
#
42Y13=Le nom de colonne ''{0}'' figure plusieurs fois dans l''instruction CREATE VIEW.

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
42Y16=Aucune m\u00E9thode statique publique ''{0}'' n''a \u00E9t\u00E9 trouv\u00E9e dans la classe ''{1}''. La m\u00E9thode peut exister mais elle n''est pas publique ou elle n''est pas statique. 

# Arguments:
#
#    {0} = aggregateType
#    {1} = type
#
42Y22=L''agr\u00E9gat {0} ne peut pas fonctionner sur le type {1}.

# Arguments:
#
#    {0} = colunmName
#
42Y23=Informations sur le type JDBC incorrectes renvoy\u00E9es pour la colonne {0}.

# Arguments:
#
#    {0} = viewName
#
42Y24=La vue ''{0}'' ne peut pas \u00EAtre mise \u00E0 jour. (Les vues ne peuvent pas \u00EAtre mises \u00E0 jour actuellement.) 

# Arguments:
#
#    {0} = tableName
#
42Y25=''{0}'' est une table syst\u00E8me. Les utilisateurs ne sont pas autoris\u00E9s \u00E0 modifier le contenu de cette table.

42Y26=Les agr\u00E9gats ne sont pas autoris\u00E9s dans la liste GROUP BY.

42Y27=Les param\u00E8tres ne sont pas autoris\u00E9s dans l''action du d\u00E9clencheur.

42Y29=La liste SELECT d''une requ\u00EAte non group\u00E9e contient au moins une expression non valide. Lorsque la liste SELECT contient au moins un agr\u00E9gat, toutes les entr\u00E9es doivent \u00EAtre des expressions d''agr\u00E9gation valides.

42Y30=La liste SELECT d''une requ\u00EAte group\u00E9e contient au moins une expression non valide. Si une liste SELECT comporte un \u00E9l\u00E9ment GROUP BY, la liste ne peut contenir que des expressions de regroupement et d''agr\u00E9gation valides.  

# Arguments:
#
#    {0} = className
#    {1} = aggregateName
#    {2} = type
#
42Y32=La classe d''agr\u00E9gateur ''{0}'' pour l''agr\u00E9gat ''{1}'' sur le type {2} n''impl\u00E9mente pas org.apache.derby.iapi.sql.execute.ExecAggregator. 

# Arguments:
#
#    {0} = aggregateName
#
42Y33=L''agr\u00E9gat {0} contient des agr\u00E9gats.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
42Y34=Le nom de colonne ''{0}'' correspond \u00E0 plusieurs colonnes de r\u00E9sultats dans la table ''{1}''.

# Arguments:
#
#    {0} = reference
#
42Y35=La r\u00E9f\u00E9rence de colonne ''{0}'' n''est pas valide. Lorsque la liste SELECT contient au moins un agr\u00E9gat, toutes les entr\u00E9es doivent \u00EAtre des expressions d''agr\u00E9gation valides.  

# Arguments:
#
#    {0} = reference
#
42Y36=La r\u00E9f\u00E9rence de colonne ''{0}'' n''est pas valide ou fait partie d''une expression non valide. Pour une liste SELECT comportant un \u00E9l\u00E9ment GROUP BY, les colonnes et les expressions s\u00E9lectionn\u00E9es ne peuvent contenir que des expressions de regroupement et d''agr\u00E9gation valides.

# Arguments:
#
#    {0} = javaTypeName
#
42Y37=''{0}'' est de type Java primitif et ne peut pas \u00EAtre utilis\u00E9 avec cet op\u00E9rateur.

# Arguments:
#
#    {0} = tableName
#
42Y38=insertMode = replace n''est pas autoris\u00E9 sur une insertion lorsque la table cible ''{0}'' est r\u00E9f\u00E9renc\u00E9e dans l''\u00E9l\u00E9ment SELECT.

# Arguments:
#
#    {0} = sqlObjectName
#
42Y39=''{0}'' ne peut pas figurer dans une d\u00E9finition CHECK CONSTRAINT car il peut renvoyer des r\u00E9sultats non d\u00E9terministes.

# Arguments:
#
#    {0} = columnName
#    {1} = triggerName
#
42Y40=''{0}'' figure plusieurs fois dans la liste de colonnes UPDATE OF pour le d\u00E9clencheur ''{1}''.

# Arguments:
#
#    {0} = storedPreparedStatementName
#
42Y41=''{0}'' ne peut pas \u00EAtre appel\u00E9 directement via EXECUTE STATEMENT car il fait partie d''un d\u00E9clencheur.

# Arguments:
#
#    {0} = dataType
#    {1} = scaleValue
#
42Y42=L''\u00E9chelle ''{1}'' n''est pas une \u00E9chelle valide pour un \u00E9l\u00E9ment {0}.

# Arguments:
#
#    {0} = scaleValue
#    {1} = precision
#
42Y43=L''\u00E9chelle ''{0}'' n''est pas une \u00E9chelle valide avec une pr\u00E9cision de ''{1}''.

# Arguments:
#
#    {0} = key
#    {1} = key
#
42Y44=Cl\u00E9 non valide ''{0}'' indiqu\u00E9e dans la liste Propri\u00E9t\u00E9s d''une liste FROM. Les cl\u00E9s respectant les minuscules et les majuscules actuellement prises en charge sont ''{1}''. 

# Arguments:
#
#    {0} = vtiName
#
42Y45=La VTI ''{0}'' ne peut pas \u00EAtre li\u00E9e parce qu''il s''agit d''une VTI de d\u00E9clencheur sp\u00E9ciale et que cette instruction ne fait pas partie d''une action de d\u00E9clencheur ou d''une clause WHEN.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y46=Liste Propri\u00E9t\u00E9s non valide dans la liste FROM. Il n''existe aucun index ''{0}'' sur la table ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
42Y48=Liste Propri\u00E9t\u00E9s non valide dans la liste FROM. Soit il n''existe aucune contrainte nomm\u00E9e ''{0}''sur la table ''{1}'', soit la contrainte ne poss\u00E8de pas d''index de secours.

# Arguments:
#
#    {0} = key
#
42Y49=Plusieurs valeurs sont indiqu\u00E9es pour la cl\u00E9 de propri\u00E9t\u00E9 ''{0}''. 

# Arguments:
#
#    {0} = tableName
#
42Y50=La liste Propri\u00E9t\u00E9s pour la table ''{0}'' peut contenir des valeurs pour l''index ou pour la contrainte, mais pas pour les deux.

# Arguments:
#
#    {0} = sqlText
#    {1} = sqlObjectName
#
42Y55=''{0}'' ne peut pas \u00EAtre ex\u00E9cut\u00E9 sur ''{1}'' car il n''existe pas.

# Arguments:
#
#    {0} = strategyValue
#    {1} = tableName
#
42Y56=Strat\u00E9gie de jointure non valide ''{0}'' indiqu\u00E9e dans la liste Propri\u00E9t\u00E9s sur la table ''{1}''. Les valeurs actuellement prises en charge pour une strat\u00E9gie de jointure sont : ''hash'' et ''nestedloop''.

# Arguments:
#
#    {0} = invalidNumber
#    {1} = optimizerOverrideName
#
42Y58=L''exception NumberFormatException s''est produite lors de la conversion de la valeur ''{0}'' pour l''\u00E9l\u00E9ment de substitution d''optimiseur ''{1}''.

# Arguments:
#
#    {0} = invalidNumber
#
42Y59=Valeur non valide ''{0}'' indiqu\u00E9e pour l''\u00E9l\u00E9ment de substitution hashInitialCapacity. La valeur doit \u00EAtre sup\u00E9rieure \u00E0 0.

# Arguments:
#
#    {0} = invalidNumber
#
42Y60=Valeur non valide ''{0}'' indiqu\u00E9e pour l''\u00E9l\u00E9ment de substitution hashLoadFactor. La valeur doit \u00EAtre sup\u00E9rieure \u00E0 0 et inf\u00E9rieure ou \u00E9gale \u00E0 1.

# Arguments:
#
#    {0} = invalidNumber
#
42Y61=Valeur non valide ''{0}'' indiqu\u00E9e pour l''\u00E9l\u00E9ment de substitution hashMaxCapacity. La valeur doit \u00EAtre sup\u00E9rieure \u00E0 0.

# Arguments:
#
#    {0} = statement
#    {1} = viewName
#
42Y62=''{0}'' n''est pas autoris\u00E9 sur ''{1}'' car il s''agit d''une vue.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#
42Y63=Une jointure par hachage n\u00E9cessite un pr\u00E9dicat equijoin optimisable sur une colonne dans l''index ou la portion de m\u00E9moire s\u00E9lectionn\u00E9. Aucun pr\u00E9dicat equijoin optimisable n''existe dans aucune colonne de la table ou de l''index ''{0}''. Utilisez l''\u00E9l\u00E9ment de substitution d''optimiseur ''index'' pour sp\u00E9cifier cet index ou cette portion de m\u00E9moire sur la table ''{1}''.

# Arguments:
#
#    {0} = invalidNumber
#
42Y64=La valeur bulkFetch de ''{0}'' n''est pas valide. La valeur minimale de bulkFetch est 1.

# Arguments:
#
#    {0} = joinType
#
42Y65=bulkFetch n''est pas autoris\u00E9 sur les jointures ''{0}''.

42Y66=bulkFetch n''est pas autoris\u00E9 sur les curseurs pouvant \u00EAtre mis \u00E0 jour. 

# Arguments:
#
#    {0} = schemaNamet
#
42Y67=Le sch\u00E9ma ''{0}'' ne peut pas \u00EAtre supprim\u00E9.

42Y69=Aucun plan d''ex\u00E9cution valide n''a \u00E9t\u00E9 trouv\u00E9 pour cette instruction. Deux causes possibles : vous avez sp\u00E9cifi\u00E9 une strat\u00E9gie de jointure par hachage alors que les jointures par hachage ne sont pas autoris\u00E9es (pas d''equijoin optimisable) ou vous essayez de joindre deux tables virtuelles externes o\u00F9 chacune r\u00E9f\u00E9rence l''autre, de sorte que l''instruction ne peut pas \u00EAtre \u00E9valu\u00E9e.  

42Y70=L''utilisateur a indiqu\u00E9 un ordre de jointure interdit. Cela peut \u00EAtre d\u00FB au fait qu''une colonne de jointure d''une table interne est transmise en tant que param\u00E8tre \u00E0 une table virtuelle externe.

# Arguments:
#
#    {0} = procedureName
#
42Y71=La proc\u00E9dure ou la fonction syst\u00E8me ''{0}'' ne peut pas \u00EAtre supprim\u00E9e.

# Arguments:
#
#    {0} = statement
#
42Y82=L''instruction pr\u00E9par\u00E9e stock\u00E9e ''{0}'' g\u00E9n\u00E9r\u00E9e par le syst\u00E8me ne peut pas \u00EAtre supprim\u00E9e \u00E0 l''aide de l''instruction DROP STATEMENT. Elle fait partie d''un d\u00E9clencheur. 

# Arguments:
#
#    {0} = aggregateName
#
42Y83=Une valeur NULL sans type n''est pas autoris\u00E9e en tant qu''argument pour l''agr\u00E9gat {0}. Affectez la valeur NULL \u00E0 un type appropri\u00E9.

# Arguments:
#
#    {0} = sqlText
#
42Y84=''{0}'' peut ne pas appara\u00EEtre dans une d\u00E9finition DEFAULT.

42Y85=Le mot-cl\u00E9 DEFAULT est autoris\u00E9 dans une clause VALUES uniquement lorsque cette clause figure dans une instruction INSERT.

42Y90=FOR UPDATE n''est pas autoris\u00E9 dans ce type d''instruction.  

42Y91=La clause USING n''est pas autoris\u00E9e dans une instruction EXECUTE STATEMENT pour une action de d\u00E9clencheur.

# Arguments:
#
#    {0} = sqlKeyword
#    {1} = sqlKeyword
#
42Y92=Les d\u00E9clencheurs {0} peuvent uniquement faire r\u00E9f\u00E9rence aux variables/tables de transition {1}.

42Y93=Clause REFERENCING interdite : un seul nom est autoris\u00E9 pour chaque type de variable/table de transition.

42Y94=Un op\u00E9rateur AND ou OR poss\u00E8de un op\u00E9rande non bool\u00E9en. Les op\u00E9randes de AND et OR doivent avoir pour r\u00E9sultat TRUE, FALSE ou UNKNOWN.  

# Arguments:
#
#    {0} = operatorName
#    {1} = operandType
#    {2} = operandType
#
42Y95=L''op\u00E9rateur ''{0}'' ayant comme type d''op\u00E9rande de gauche ''{1}'' et comme type d''op\u00E9rande de droite ''{2}'' n''est pas pris en charge.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
42Y97=Caract\u00E8re d''\u00E9chappement non valide \u00E0 la ligne ''{0}'', colonne ''{1}''.

42Z02=Les agr\u00E9gats DISTINCT multiples ne sont pas pris en charge pour le moment.

42Z07=Les agr\u00E9gats ne sont pas autoris\u00E9s dans la clause ON.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
42Z08=Une op\u00E9ration d''insertion/remplacement en masse n''est pas autoris\u00E9e sur ''{0}'' car elle contient un d\u00E9clencheur activ\u00E9 ({1}).

# Arguments:
#
#    {0} = columnName
#
42Z15=Type non valide indiqu\u00E9 pour la colonne ''{0}''. Le type d''une colonne ne peut pas \u00EAtre modifi\u00E9.  

42Z16=Seule la longueur des colonnes de type VARCHAR, CLOB et BLOB peut \u00EAtre modifi\u00E9e. 

# Arguments:
#
#    {0} = columnName
#
42Z17=Longueur non valide indiqu\u00E9e pour la colonne ''{0}''. La longueur doit \u00EAtre sup\u00E9rieure \u00E0 la longueur de colonne en cours.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z18=La colonne ''{0}'' fait partie d''une contrainte de cl\u00E9 \u00E9trang\u00E8re ''{1}''. Pour modifier la longueur de cette colonne, vous devez d''abord supprimer la contrainte, ex\u00E9cuter ALTER TABLE, puis recr\u00E9er la contrainte.

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z19=La colonne ''{0}'' est r\u00E9f\u00E9renc\u00E9e par au moins une contrainte de cl\u00E9 \u00E9trang\u00E8re ''{1}''. Pour modifier la longueur de cette colonne, vous devez d''abord supprimer les contraintes de r\u00E9f\u00E9rence, ex\u00E9cuter ALTER TABLE, puis recr\u00E9er les contraintes. 

# Arguments:
#
#    {0} = columnName
#
42Z20=La colonne ''{0}'' ne peut pas accepter la valeur NULL. Elle fait partie d''une cl\u00E9 primaire ou d''une contrainte unique qui ne peut pas contenir de colonnes ayant une valeur NULL.

# Arguments:
#
#    {0} = columnName
#
42Z20.S.1=La colonne ''{0}'' ne peut pas accepter la valeur NULL. Elle fait partie d''une cl\u00E9 primaire qui ne peut pas contenir de colonnes ayant la valeur NULL.

# Arguments:
#
#    {0} = columnName
#
42Z21=Incr\u00E9ment non valide indiqu\u00E9 pour l''identit\u00E9 de la colonne ''{0}''. L''incr\u00E9ment ne peut pas \u00EAtre de z\u00E9ro.  

# Arguments:
#
#    {0} = columnName
#
42Z22=Type non valide indiqu\u00E9 pour la colonne d''identit\u00E9 ''{0}''. Les seuls types valides pour les colonnes d''identit\u00E9 sont BIGINT, INT et SMALLINT.

# Arguments:
#
#    {0} = columnName
#
42Z23=Tentative de modification de la colonne d''identit\u00E9 ''{0}''. 

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
42Z24=Un d\u00E9passement est survenu dans la valeur d''identit\u00E9 pour la colonne ''{1}'' dans la table ''{0}''.

42Z25=Erreur interne - Compteur d''identit\u00E9. Une mise \u00E0 jour a \u00E9t\u00E9 appel\u00E9e sans argument avec la valeur en cours \= NULL.

# Arguments:
#
#    {0} = columnName
#
42Z26=La colonne ''{0}'' avec une valeur d''identit\u00E9 par d\u00E9faut ne peut pas prendre la valeur NULL.

# Arguments:
#
#    {0} = columnName
#
42Z27=La colonne pouvant prendre la valeur NULL ''{0}'' ne peut pas \u00EAtre modifi\u00E9e pour prendre une valeur d''identit\u00E9 par d\u00E9faut.

# Arguments:
#
#    {0} = queryTreeNodeIdentifier
#
42Z50=Erreur interne : impossible de g\u00E9n\u00E9rer du code pour {0}.

# Arguments:
#
#    {0} = number
#
42Z53=Erreur interne : le type d''activation \u00E0 g\u00E9n\u00E9rer pour le choix de noeud {0} est inconnu.

# Arguments:
#
#    {0} = sqlText
#    {1} = propertyName
#    {2} = propertyValue
#
42Z60={0} est interdit, sauf si la propri\u00E9t\u00E9 de base de donn\u00E9es {1} a pour valeur ''{2}''.

42Z70=La liaison directe avec une valeur XML n''est pas autoris\u00E9e. Utilisez XMLPARSE.

42Z71=Les valeurs XML ne sont pas autoris\u00E9es dans les ensembles de r\u00E9sultats de niveau sup\u00E9rieur. Utilisez XMLSERIALIZE.

# Arguments:
#
#    {0} = keywords
#    {1} = lineNumber
#    {2} = columnNumber
#
42Z72=Mots-cl\u00E9s SQL/XML ''{0}'' manquants \u00E0 la ligne {1}, colonne {2}.

# Arguments:
#
#    {0} = typeName
#
42Z73=Type cible non valide pour XMLSERIALIZE : ''{0}''.

# Arguments:
#
#    {0} = featureName
#
42Z74=Fonctionnalit\u00E9 XML non prise en charge : ''{0}''.

42Z75=L''expression de requ\u00EAte XML doit \u00EAtre un litt\u00E9ral de cha\u00EEne.

42Z76=Les \u00E9l\u00E9ments contextuels XML multiples ne sont pas autoris\u00E9s.

# Arguments:
#
#    {0} = dataType
#
42Z77=L''\u00E9l\u00E9ment contextuel doit avoir pour type ''XML'' ; ''{0}'' n''est pas autoris\u00E9.

42Z79=Impossible de d\u00E9terminer le type de param\u00E8tre associ\u00E9 \u00E0 XMLPARSE. Essayez d''utiliser CAST.

# Arguments:
#
#    {0} = className
#
42Z90=La classe ''{0}'' ne renvoie pas un ensemble ResultSet pouvant \u00EAtre mis \u00E0 jour.

# This is a kind of query fragment, which may or may not appear in certain query contexts.
#
42Z91=SELECT

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z92=lecture reproductible

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintName
#
42Z93=Les contraintes ''{0}'' et ''{1}'' poss\u00E8dent le m\u00EAme ensemble de colonnes, ce qui n''est pas autoris\u00E9. 

# Arguments:
#
#    {0} = columnName
#    {1} = constraintName
#
42Z97=Le changement du nom de la colonne ''{0}'' entra\u00EEnera la rupture de la contrainte CHECK ''{1}''.

42Z99=Un litt\u00E9ral de type String ou Hex ne peut pas d\u00E9passer 64 Ko.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
#
42Z9A=lecture non valid\u00E9e (commit)

42Z9D.S.1=Les proc\u00E9dures modifiant les donn\u00E9es SQL ne sont pas autoris\u00E9es dans les d\u00E9clencheurs BEFORE.

# Arguments:
#
#    {0} = statement
#    {1} = triggerName
#
42Z9D=Les instructions ''{0}'' ne sont pas autoris\u00E9es dans les d\u00E9clencheurs ''{1}''.

# Arguments:
#
#    {0} = constraintName
#    {1} = constraintType
#
42Z9E=La contrainte ''{0}'' n''est pas une contrainte {1}.

# Arguments:
#
#    {0} = index
#    {1} = tableName
#    {2} = number
#
42Z9F=Trop d''index ({0}) pour la table {1}. La limite est {2}.  

42ZA0=Instruction trop complexe. Essayez de r\u00E9\u00E9crire la requ\u00EAte afin de la simplifier. L''\u00E9limination de nombreuses expressions en double ou la rupture de la requ\u00EAte et le stockage des r\u00E9sultats interm\u00E9diaires dans une table temporaire permettent souvent de r\u00E9soudre cette erreur.

# Arguments:
#
#    {0} = batch
#
42ZA1=Langage SQL non valide dans le batch : ''{0}''.

# Arguments:
#
#    {0} = dataType
#    {1} = collationType
#    {2} = dataType
#    {3} = collationType
#
42ZA2=L''op\u00E9rande du pr\u00E9dicat LIKE avec le type {0} et le classement {1} est incompatible avec l''op\u00E9rande de mod\u00E8le LIKE avec le type {2} et le classement {3}.

# Arguments:
#
#    {0} = collationType
#    {1} = schemaName
#
42ZA3=La table disposera du type de classement {0}, diff\u00E9rent du classement du sch\u00E9ma {1} ; cette op\u00E9ration n''est donc pas prise en charge.

42ZB1=Le style de param\u00E8tre DERBY_JDBC_RESULT_SET est uniquement autoris\u00E9 pour les fonctions de table.

42ZB2=Les fonctions de table peuvent uniquement disposer du style de param\u00E8tre DERBY_JDBC_RESULT_SET.

42ZB3=XML n''est pas autoris\u00E9 en tant que type de donn\u00E9es d''une colonne renvoy\u00E9e par une fonction de table.

# Arguments:
#
#    {0} = schemaName
#    {1} = functionName
#
42ZB4=''{0}''.{1}'' n''identifie pas une fonction de table.

# Arguments:
#
#    {0} = className
#
42ZB5=La classe ''{0}'' impl\u00E9mente VTICosting mais ne fournit pas de constructeur sans argument public.

42ZB6=Une valeur scalaire est attendue, non pas un ensemble de lignes renvoy\u00E9 par une fonction de table.

# Arguments:
#
#    {0} = columnName
#
42ZB7=R\u00E9f\u00E9rence interdite \u00E0 la colonne ''{0}'' par une fonction de table ou une VTI.

# Arguments:
#
#    {0} = windowName
#
42ZC0=La fen\u00EAtre ''{0}'' n''est pas d\u00E9finie.

42ZC1=Une seule fen\u00EAtre est prise en charge.

# Arguments:
#
#    {0} = clauseName
#
42ZC2=La fonction de fen\u00EAtre n''est pas autoris\u00E9e dans ce contexte : clause ''{0}''

# Arguments:
#
#    {0} = aggregateName
#
42ZC3=Un agr\u00E9gat d\u00E9fini par l''utilisateur peut ne pas poss\u00E9der le nom d''un agr\u00E9gat d\u00E9fini par la norme SQL ou d''une fonction Derby int\u00E9gr\u00E9e comportant un argument : ''{0}''

# Arguments:
#
#    {0} = codePage
#    {1} = codePage
#
57017.C=Aucune conversion n''est disponible pour la page de code source {0} vers la page de code cible {1}. La connexion a \u00E9t\u00E9 interrompue.

58009.C.10=Exception de protocole r\u00E9seau : seule l''une des longueurs VCM ou VCS peut \u00EAtre sup\u00E9rieure \u00E0 0. La connexion a \u00E9t\u00E9 interrompue.

58009.C.11=La connexion a \u00E9t\u00E9 interrompue car le codage n''est pas pris en charge.

# Arguments:
#
#    {0} = codePoint
#    {1} = codePoint
#
58009.C.12=Exception de protocole r\u00E9seau : le point de code r\u00E9el {0} ne correspond pas au point de code pr\u00E9vu {1}. La connexion a \u00E9t\u00E9 interrompue.

58009.C.13=Exception de protocole r\u00E9seau : la collection DDM contient moins de 4 octets de donn\u00E9es. La connexion a \u00E9t\u00E9 interrompue.

58009.C.14=Exception de protocole r\u00E9seau : pile de collecte non vide \u00E0 la fin de l''analyse syntaxique de la cha\u00EEne d''ID identiques. La connexion a \u00E9t\u00E9 interrompue.

58009.C.15=Exception de protocole r\u00E9seau : longueur DSS non nulle \u00E0 la fin de l''analyse syntaxique de la cha\u00EEne d''ID identiques. La connexion a \u00E9t\u00E9 interrompue.

58009.C.16=Exception de protocole r\u00E9seau : DDS cha\u00EEn\u00E9 avec le m\u00EAme ID \u00E0 la fin de l''analyse syntaxique de la cha\u00EEne d''ID identiques. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = number
#
58009.C.17=Exception de protocole r\u00E9seau : fin de flux pr\u00E9matur\u00E9e lors de la lecture d''InputStream, param\u00E8tre n\u00B0{0}. La connexion a \u00E9t\u00E9 interrompue.

58009.C.18=Exception de protocole r\u00E9seau : FDOCA LID non valide. La connexion a \u00E9t\u00E9 interrompue.

58009.C.19=Exception de protocole r\u00E9seau : SECTKN non renvoy\u00E9. La connexion a \u00E9t\u00E9 interrompue.

58009.C.20=Exception de protocole r\u00E9seau : seule l''une des valeurs NVCM ou NVCS peut \u00EAtre non NULL. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = length
#
58009.C.21=Exception de protocole r\u00E9seau : la longueur SCLDTA {0} n''est pas valide pour RDBNAM. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = length
#
58009.C.7=Exception de protocole r\u00E9seau : la longueur SCLDTA {0} n''est pas valide pour RDBCOLID. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = length
#
58009.C.8=Exception de protocole r\u00E9seau : la longueur SCLDTA {0} n''est pas valide pour PKGID. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = length
#    {1} = sqlApplicationManager
#
58009.C.9=Exception de protocole r\u00E9seau : la longueur PKGNAMCSN {0} n''est pas valide pour SQLAM {1}. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = managerCodePoint
#    {1} = level
#
58010.C=Une erreur de protocole r\u00E9seau s''est produite. Impossible d''\u00E9tablir une connexion car le gestionnaire {0} de niveau {1} n''est pas pris en charge par le serveur. 

# Arguments:
#
#    {0} = distributedDataManagementCommand
#
58014.C=La commande DDM 0x{0} n''est pas prise en charge. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = distributedDataManagementObject
#
58015.C=L''objet DDM 0x{0} n''est pas pris en charge. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = distributedDataManagementParameter
#
58016.C=Le param\u00E8tre DDM 0x{0} n''est pas pris en charge. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = distributedDataManagementParameterValue
#
58017.C=La valeur de param\u00E8tre DDM 0x{0} n''est pas prise en charge. Une variable h\u00F4te d''entr\u00E9e ne se situe peut-\u00EAtre pas dans la plage prise en charge par le serveur. La connexion a \u00E9t\u00E9 interrompue.

# Arguments:
#
#    {0} = columnName
#
X0A00.S=La liste de s\u00E9lection mentionne la colonne ''{0}'' deux fois. Ceci n''est pas autoris\u00E9 dans les requ\u00EAtes contenant des clauses GROUP BY ou HAVING. Essayez de d\u00E9finir l''alias de l''une des colonnes en conflit sur un nom unique.

# Arguments:
#
#    {0} = tableName
#    {1} = mode
#
X0X02.S=La table ''{0}'' ne peut pas \u00EAtre verrouill\u00E9e en mode ''{1}''.

X0X03.S=Etat de transaction non valide. La conservation du curseur requiert le m\u00EAme niveau d''isolement

# Arguments:
#
#    {0} = tableName
#
X0X05.S=La table/vue ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = fileName
#    {1} = classpath
#
X0X07.S=Impossible d''enlever le fichier JAR ''{0}'' car il se trouve sur le chemin derby.database.classpath ''{0}''.

# Arguments:
#
#    {0} = columnArrayLength
#
X0X0D.S=Longueur du tableau de colonnes ''{0}'' non valide. Pour renvoyer les cl\u00E9s g\u00E9n\u00E9r\u00E9es, le tableau de colonnes doit avoir une longueur de 1 et ne doit contenir que la colonne d''identit\u00E9.

# Arguments:
#
#    {0} = columnPosition
#    {1} = tableName
#
X0X0E.S=La table ''{1}'' ne dispose pas d''une colonne \u00E0 g\u00E9n\u00E9ration automatique \u00E0 la position de colonne ''{0}''.

# Arguments:
#
#    {0} = columnName
#    {1} = tableName
#
X0X0F.S=La table ''{1}'' ne dispose pas d''une colonne \u00E0 g\u00E9n\u00E9ration automatique nomm\u00E9e ''{0}''.

X0X10.S=La clause USING a renvoy\u00E9 plusieurs lignes. Seuls les \u00E9l\u00E9ments ResultSets comportant une seule ligne sont autoris\u00E9s.

X0X11.S=La clause USING n''a renvoy\u00E9 aucun r\u00E9sultat ; aucun param\u00E8tre ne peut \u00EAtre d\u00E9fini. 

# Arguments:
#
#    {0} = fileName
#    {1} = schemaNamet
#
X0X13.S=Le fichier JAR ''{0}'' n''existe pas dans le sch\u00E9ma ''{1}''.

# Arguments:
#
#    {0} = type
#
X0X57.S=Une tentative de placement d''une valeur Java de type ''{0}'' dans une valeur SQL a \u00E9t\u00E9 effectu\u00E9e alors qu''il n''existe aucun type SQL correspondant. La valeur Java est probablement le r\u00E9sultat d''un appel de m\u00E9thode ou de l''acc\u00E8s \u00E0 un champ.

# Arguments:
#
#    {0} = cursorName
#
X0X60.S=Un curseur ayant pour nom ''{0}'' existe d\u00E9j\u00E0.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaName
#    {2} = tableName
#    {3} = rowLocation
#    {4} = columnName
#    {5} = dataValue
#    {6} = dataValue
#    {7} = indexKey
#
X0X61.S=Les valeurs pour la colonne ''{4}'' dans l''index ''{0}'' et la table ''{1}.{2}'' ne correspondent pas \u00E0 l''emplacement de ligne {3}. La valeur dans l''index est ''{5}'', tandis que la valeur dans la table de base est ''{6}''. La cl\u00E9 d''index compl\u00E8te, qui comprend l''emplacement de ligne, est ''{7}''. L''intervention sugg\u00E9r\u00E9e consiste \u00E0 recr\u00E9er l''index.

# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#    {2} = rowLocation
#    {3} = indexKey
#
X0X62.S=Incoh\u00E9rence d\u00E9tect\u00E9e entre la table ''{0}'' et l''index ''{1}''. Erreur lors de la tentative d''extraction de l''emplacement de ligne ''{2}'' \u00E0 partir de la table. La cl\u00E9 d''index compl\u00E8te, qui comprend l''emplacement de ligne, est ''{3}''. L''intervention sugg\u00E9r\u00E9e consiste \u00E0 recr\u00E9er l''index.

# Arguments:
#
#    {0} = exceptionText
#
X0X63.S=Exception IOException obtenue : ''{0}''.

# Arguments:
#
#    {0} = type
#
X0X67.S=Les colonnes de type ''{0}'' ne peuvent pas \u00EAtre utilis\u00E9es dans les instructions CREATE INDEX, ORDER BY, GROUP BY, UNION, INTERSECT, EXCEPT et DISTINCT car les comparaisons ne sont pas prises en charge pour ce type.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0X81.S={0} ''{1}'' n''existe pas.

# Arguments:
#
#    {0} = indexName
#    {1} = indexType
#
X0X85.S=L''index ''{0}'' n''a pas \u00E9t\u00E9 cr\u00E9\u00E9 car ''{1}'' n''est pas un type d''index valide.

X0X86.S=0 est une valeur de param\u00E8tre non valide pour ResultSet.absolute(int row).

X0X87.S=ResultSet.relative(int row) ne peut pas \u00EAtre appel\u00E9 lorsque le curseur n''est pas positionn\u00E9 sur une ligne.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#
X0X95.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre ex\u00E9cut\u00E9e sur l''objet ''{1}'' car il existe un \u00E9l\u00E9ment ResultSet ouvert d\u00E9pendant de cet objet.

# Arguments:
#
#    {0} = indexName
#
X0X99.S=L''index ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = sqlObjectName
#
X0Y16.S=''{0}'' n''est pas une vue. S''il s''agit d''une table, utilisez plut\u00F4t DROP TABLE.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = viewName
#
X0Y23.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre effectu\u00E9e sur l''objet ''{1}'' car VIEW ''{2}'' d\u00E9pend de cet objet.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = statement
#
X0Y24.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre effectu\u00E9e sur l''objet ''{1}'' car STATEMENT ''{2}'' d\u00E9pend de cet objet.

# Arguments:
#
#    {0} = operationName
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y25.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre effectu\u00E9e sur l''objet ''{1}'' car {2} ''{3}'' d\u00E9pend de cet objet.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y26.S=L''index ''{0}'' doit se trouver dans le m\u00EAme sch\u00E9ma que la table ''{1}''.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y28.S=L''index ''{0}'' ne peut pas \u00EAtre cr\u00E9\u00E9 sur la table syst\u00E8me ''{1}''. Les utilisateurs ne peuvent pas cr\u00E9er d''index sur les tables syst\u00E8me.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = tableName
#
X0Y29.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre effectu\u00E9e sur l''objet ''{1}'' car TABLE ''{2}'' d\u00E9pend de cet objet.

# Arguments:
#
#    {0} = operationName
#    {1} = objectName
#    {2} = routineName
#
X0Y30.S=L''op\u00E9ration ''{0}'' ne peut pas \u00EAtre effectu\u00E9e sur l''objet ''{1}'' car ROUTINE ''{2}'' d\u00E9pend de cet objet.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#    {2} = sqlObjectType
#    {3} = sqlObjectName
#
X0Y32.S={0} ''{1}'' existe d\u00E9j\u00E0 dans {2} ''{3}''.

# Arguments:
#
#    {0} = indexName
#    {1} = tableName
#
X0Y38.S=Impossible de cr\u00E9er l''index ''{0}'' car la table ''{1}'' n''existe pas.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = tableName
#
X0Y41.S=La contrainte ''{0}'' n''est pas valide car la table r\u00E9f\u00E9renc\u00E9e {1} ne comporte aucune cl\u00E9 primaire. Vous pouvez soit ajouter une cl\u00E9 primaire \u00E0 {1} soit sp\u00E9cifier explicitement les colonnes d''une contrainte unique \u00E0 laquelle cette cl\u00E9 \u00E9trang\u00E8re fait r\u00E9f\u00E9rence. 

# Arguments:
#
#    {0} = constraintName
#
X0Y42.S=La contrainte ''{0}'' n''est pas valide : les types des colonnes de cl\u00E9 \u00E9trang\u00E8re ne correspondent pas aux types des colonnes r\u00E9f\u00E9renc\u00E9es.

# Arguments:
#
#    {0} = constraintName
#    {1} = number
#    {2} = number
#
X0Y43.S=La contrainte ''{0}'' n''est pas valide : le nombre de colonnes ({1}) ne correspond pas au nombre de colonnes de la cl\u00E9 r\u00E9f\u00E9renc\u00E9e ({2}).

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y44.S=La contrainte ''{0}'' n''est pas valide : aucune contrainte de cl\u00E9 unique ou primaire de la table ''{1}'' ne correspond au nombre et aux types des colonnes de la cl\u00E9 \u00E9trang\u00E8re.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y45.S=La contrainte de cl\u00E9 \u00E9trang\u00E8re ''{0}'' ne peut pas \u00EAtre ajout\u00E9e ou activ\u00E9e dans la table {1} car certaines cl\u00E9s \u00E9trang\u00E8res ne poss\u00E8dent pas de cl\u00E9s r\u00E9f\u00E9renc\u00E9es correspondantes.  

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#
X0Y46.S=La contrainte ''{0}'' n''est pas valide : la table r\u00E9f\u00E9renc\u00E9e {1} n''existe pas.

# Arguments:
#
#    {0} = schemaNamet
#
X0Y54.S=Le sch\u00E9ma ''{0}'' ne peut pas \u00EAtre supprim\u00E9 car il n''est pas vide.

# Arguments:
#
#    {0} = indexName
#    {1} = schemaNamet
#    {2} = tableName
#    {3} = number
#    {4} = number
#
X0Y55.S=Le nombre de lignes de la table de base ne correspond pas au nombre de lignes d''au moins 1 des index de la table. L''index ''{0}'' de la table ''{1}.{2}'' comprend {3} lignes mais la table de base en comprend {4}. L''intervention sugg\u00E9r\u00E9e consiste \u00E0 recr\u00E9er l''index.

# Arguments:
#
#    {0} = sqlText
#    {1} = tableName
#
X0Y56.S=''{0}'' n''est pas autoris\u00E9 sur la table syst\u00E8me ''{1}''.

# Arguments:
#
#    {0} = tableName
#
X0Y57.S=Une colonne n''acceptant pas la valeur NULL ne peut pas \u00EAtre ajout\u00E9e \u00E0 la table ''{0}'' car celle-ci contient au moins une ligne. Les colonnes n''acceptant pas la valeur NULL peuvent uniquement \u00EAtre ajout\u00E9es \u00E0 des tables vides.

# Arguments:
#
#    {0} = tableName
#
X0Y58.S=Echec de la tentative d''ajout d''une contrainte de cl\u00E9 primaire \u00E0 la table ''{0}'' car celle-ci contient d\u00E9j\u00E0 une contrainte de ce type. Une table ne peut poss\u00E9der qu''une seule contrainte de cl\u00E9 primaire.

# Arguments:
#
#    {0} = constraintName
#    {1} = tableName
#    {2} = rowCount
#
X0Y59.S=Echec de la tentative d''ajout ou d''activation de contraintes sur la table ''{1}'' car celle-ci contient {2} ligne(s) qui violent les contraintes CHECK suivantes : {0}.

# Arguments:
#
#    {0} = tableName
#
X0Y63.S=Echec de la commande sur la table ''{0}'' car des donn\u00E9es NULL ont \u00E9t\u00E9 d\u00E9tect\u00E9es dans des colonnes d''index/de contrainte de cl\u00E9 primaire ou unique. Aucune colonne d''une cl\u00E9 d''index primaire ou unique ne doit comporter de valeurs NULL.  

# Arguments:
#
#    {0} = tableName
#
X0Y63.S.1=Echec de la commande sur la table ''{0}'', car les colonnes d''index/de cl\u00E9 primaire contiennent des donn\u00E9es NULL. Aucune colonne d''une cl\u00E9 primaire ne doit comporter de valeurs NULL.  

X0Y66.S=Impossible d''\u00E9mettre une validation (commit) dans une connexion imbriqu\u00E9e dont la connexion parent contient une op\u00E9ration en attente.

X0Y67.S=Impossible d''\u00E9mettre une annulation (rollback) dans une connexion imbriqu\u00E9e dont la connexion parent contient une op\u00E9ration en attente.

# Arguments:
#
#    {0} = sqlObjectType
#    {1} = sqlObjectName
#
X0Y68.S={0} ''{1}'' existe d\u00E9j\u00E0.

# Arguments:
#
#    {0} = triggerName
#
X0Y69.S=DDL n''est pas pris en charge dans le d\u00E9clencheur {0}.

# Arguments:
#
#    {0} = triggerName
#    {1} = tableName
#
X0Y70.S=INSERT, UPDATE et DELETE ne sont pas autoris\u00E9s sur la table {1} car le d\u00E9clencheur {0} est actif.

# Arguments:
#
#    {0} = triggerName
#
X0Y71.S=La manipulation de transaction, telle que SET ISOLATION, n''est pas autoris\u00E9e car le d\u00E9clencheur {0} est actif.

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
X0Y72.S=Une op\u00E9ration d''insertion/remplacement en masse n''est pas autoris\u00E9e sur ''{0}'' car elle contient un d\u00E9clencheur activ\u00E9 ({1}).

X0Y77.S=Impossible d''\u00E9mettre une instruction SET TRANSACTION ISOLATION sur une transaction globale qui est en cours car cela entra\u00EEnerait implicitement la validation (commit) de la transaction globale.

X0Y78.S=La commande Statement.executeQuery() ne peut pas \u00EAtre appel\u00E9e avec une instruction qui renvoie un nombre de lignes.

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.1=La commande {0}.executeQuery() ne peut \u00EAtre appel\u00E9e car plusieurs ensembles de r\u00E9sultats ont \u00E9t\u00E9 renvoy\u00E9s. Utilisez {1}.execute() pour obtenir plusieurs r\u00E9sultats.

# Arguments:
#
#    {0} = javaInterfaceName
#    {1} = javaInterfaceName
#
X0Y78.S.2=La commande {0}.executeQuery() a \u00E9t\u00E9 appel\u00E9e, mais aucun ensemble de r\u00E9sultats n''a \u00E9t\u00E9 renvoy\u00E9. Utilisez {1}.executeUpdate() pour les \u00E9l\u00E9ments qui ne sont pas des requ\u00EAtes.

X0Y79.S=La commande Statement.executeUpdate() ne peut pas \u00EAtre appel\u00E9e avec une instruction qui renvoie un ResultSet.

# Arguments:
#
#    {0} = tableName
#    {1} = columnName
#
X0Y80.S=Echec de l''op\u00E9ration ALTER sur la table ''{0}''. Des donn\u00E9es NULL ont \u00E9t\u00E9 trouv\u00E9es dans la colonne ''{1}''.

# Arguments:
#
#    {0} = rowName
#    {1} = id
#
X0Y83.S=Avertissement : lors de la suppression d''une ligne d''une table, la ligne d''index correspondant \u00E0 la ligne de la table de base {0} est introuvable dans l''index avec l''ID d''agglom\u00E9ration {1}. Ce probl\u00E8me a \u00E9t\u00E9 corrig\u00E9 automatiquement dans le cadre de l''op\u00E9ration de suppression.

# Arguments:
#
#    {0} = sequenceName
#
X0Y84.T=Trop de conflits sur la s\u00E9quence {0}. Ceci est probablement d\u00FB \u00E0 une analyse non valid\u00E9e du catalogue SYS.SYSSEQUENCES. N''interrogez pas ce catalogue directement. Utilisez la fonction SYSCS_UTIL.SYSCS_PEEK_AT_SEQUENCE pour visualiser la valeur en cours d''un g\u00E9n\u00E9rateur de requ\u00EAte.

# Arguments:
#
#    {0} = propertyName
#    {1} = className
#
X0Y85.S=La propri\u00E9t\u00E9 Derby ''{0}'' identifie une classe qui ne peut pas \u00EAtre instanci\u00E9e : ''{1}''. Pour plus d''informations, reportez-vous \u00E0 l''exception suivante.

# Arguments:
#
#    {0} = schemaName
#    {1} = sequenceName
#
X0Y86.S=Derby n''a pas pu obtenir les verrous n\u00E9cessaires pour lib\u00E9rer les valeurs inutilis\u00E9es et pr\u00E9affect\u00E9es de la s\u00E9quence ''{0}''.''{1}''. Par cons\u00E9quent, des vides inattendus peuvent appara\u00EEtre dans cette s\u00E9quence.

# Arguments:
#
#    {0} = schemaName
#    {1} = aggregateOrFunctionName
#
X0Y87.S=Il existe d\u00E9j\u00E0 un agr\u00E9gat ou une fonction avec un argument nomm\u00E9 ''{0}''.''{1}''.

# Arguments:
#
#    {0} = cacheName
#    {1} = keyValue
#
XBCA0.S=Impossible de cr\u00E9er un objet avec la cl\u00E9 {1} dans le cache {0}. L''objet existe d\u00E9j\u00E0 dans le cache. 

# Arguments:
#
#    {0} = className
#
XBCM1.S=Erreur de liaison Java g\u00E9n\u00E9r\u00E9e lors du chargement de la classe g\u00E9n\u00E9r\u00E9e {0}.

# Arguments:
#
#    {0} = className
#
XBCM2.S=Impossible de cr\u00E9er une instance de la classe g\u00E9n\u00E9r\u00E9e {0}.

# Arguments:
#
#    {0} = className
#    {1} = methodName
#
XBCM3.S=La m\u00E9thode {1}() n''existe pas dans la classe g\u00E9n\u00E9r\u00E9e {0}.

# Arguments:
#
#    {0} = className
#    {1} = limitDescriptor
#
XBCM4.S=Limites de format de fichier de classe Java d\u00E9pass\u00E9es : {1} dans la classe g\u00E9n\u00E9r\u00E9e {0}.

XBCX0.S=Exception issue du fournisseur de cryptographie. Pour plus de d\u00E9tails, reportez-vous \u00E0 l''exception suivante.

XBCX1.S=Initialisation du chiffrement dans un mode interdit ; ce mode doit \u00EAtre CipherFactory.ENCRYPT ou CipherFactory.DECRYPT.

# Arguments:
#
#    {0} = number
#
XBCX2.S=Initialisation du chiffrement avec un mot de passe d''amor\u00E7age trop court. Le mot de passe doit comporter au moins {0} caract\u00E8res.    

XBCX5.S=Impossible de modifier le mot de passe d''amor\u00E7age pour lui affecter la valeur NULL.

XBCX6.S=Impossible de modifier le mot de passe d''amor\u00E7age vers un type s\u00E9rialisable qui ne soit pas de type String.

XBCX7.S=Format incorrect pour modifier le mot de passe d''amor\u00E7age. Le format suivant doit \u00EAtre utilis\u00E9 : old_boot_password, new_boot_password.

XBCX8.S=Impossible de modifier le mot de passe d''amor\u00E7age pour une base de donn\u00E9es non crypt\u00E9e.

XBCX9.S=Impossible de modifier le mot de passe d''amor\u00E7age pour une base de donn\u00E9es en lecture seule.  

XBCXA.S=Mot de passe d''amor\u00E7age incorrect.

# Arguments:
#
#    {0} = paddingDirective
#
XBCXB.S=Remplissage de cryptage incorrect ''{0}'' ou remplissage non sp\u00E9cifi\u00E9. Vous devez utiliser ''NoPadding'' (aucun remplissage).

# Arguments:
#
#    {0} = algorithmName
#    {1} = providerName
#
XBCXC.S=L''algorithme de cryptage ''{0}'' n''existe pas. V\u00E9rifiez que le fournisseur choisi ''{1}'' prend en charge cet algorithme.

XBCXD.S=L''algorithme de cryptage ne peut pas \u00EAtre modifi\u00E9 une fois que la base de donn\u00E9es est cr\u00E9\u00E9e.

XBCXE.S=Le fournisseur de cryptage ne peut pas \u00EAtre modifi\u00E9 une fois que la base de donn\u00E9es est cr\u00E9\u00E9e.

# Arguments:
#
#    {0} = className
#
XBCXF.S=La classe ''{0}'' qui repr\u00E9sente le fournisseur de cryptage est introuvable.

# Arguments:
#
#    {0} = providerName
#
XBCXG.S=Le fournisseur de cryptage ''{0}'' n''existe pas.

# Arguments:
#
#    {0} = algorithmName
#
XBCXH.S=Le format de encryptionAlgorithm ''{0}'' n''est pas correct. Le format correct est algorithm/feedbackMode/NoPadding.

# Arguments:
#
#    {0} = mode
#
XBCXI.S=Le mode de commentaires ''{0}'' n''est pas pris en charge. Les modes de commentaires pris en charge sont CBC, CFB, OFB et ECB.

XBCXJ.S=L''application utilise une version de Java Cryptography Extension (JCE) ant\u00E9rieure \u00E0 1.2.1. Effectuez la mise \u00E0 niveau vers JCE 1.2.1 puis recommencez l''op\u00E9ration.    

XBCXK.S=La cl\u00E9 de cryptage donn\u00E9e ne concorde pas avec la cl\u00E9 utilis\u00E9e lors de la cr\u00E9ation de la base de donn\u00E9es. V\u00E9rifiez que vous utilisez la cl\u00E9 de cryptage correcte et r\u00E9essayez. 

XBCXL.S=La proc\u00E9dure de v\u00E9rification de la cl\u00E9 de cryptage n''a pas abouti. Cette situation peut \u00EAtre due au fait qu''une erreur s''est produite lors de l''acc\u00E8s au fichier appropri\u00E9 pour la proc\u00E9dure de v\u00E9rification. Pour plus de d\u00E9tails, reportez-vous \u00E0 l''exception suivante.  

XBCXM.S=La longueur de la cl\u00E9 de cryptage externe doit \u00EAtre un nombre pair.

XBCXN.S=La cl\u00E9 de cryptage externe contient des caract\u00E8res interdits. Les caract\u00E8res autoris\u00E9s pour un nombre hexad\u00E9cimal sont 0 \u00E0 9, a \u00E0 f et A \u00E0 F.

XBCXO.S=Impossible de crypter la base de donn\u00E9es lorsqu''une transaction globale est pr\u00E9par\u00E9e.

XBCXP.S=Impossible de crypter \u00E0 nouveau la base de donn\u00E9es avec un nouveau mot de passe d''amor\u00E7age ou une cl\u00E9 de cryptage externe lorsqu''une transaction est pr\u00E9par\u00E9e.

XBCXQ.S=Impossible de configurer une base de donn\u00E9es en lecture seule pour le cryptage.

XBCXR.S=Impossible de crypter \u00E0 nouveau une base de donn\u00E9es en lecture seule avec un nouveau mot de passe d''amor\u00E7age ou une cl\u00E9 de cryptage externe.

XBCXS.S=Impossible de configurer une base de donn\u00E9es pour le cryptage lorsque la base de donn\u00E9es est en mode d''archivage de journaux.

XBCXT.S=Impossible de crypter \u00E0 nouveau une base de donn\u00E9es avec un nouveau mot de passe d''amor\u00E7age ou une cl\u00E9 de cryptage externe lorsque la base de donn\u00E9es est en mode d''archivage de journaux.

# Arguments:
#
#    {0} = failureMessage
#
XBCXU.S=Echec du cryptage d''une base de donn\u00E9es non crypt\u00E9e : {0}

# Arguments:
#
#    {0} = failureMessage
#
XBCXV.S=Echec du cryptage d''une base de donn\u00E9es crypt\u00E9e avec une nouvelle cl\u00E9 ou un nouveau mot de passe : {0}

# Arguments:
#
#    {0} = algorithmName
#
XBCXW.S=L''algorithme de message Digest ''{0}'' n''est pas pris en charge par les fournisseurs de cryptographie disponibles. Installez un fournisseur de cryptographie prenant en charge l''algorithme ou sp\u00E9cifiez un autre algorithme dans la propri\u00E9t\u00E9 derby.authentication.builtin.algorithm.

XBM01.D=Echec du d\u00E9marrage en raison d''une exception. Pour plus de d\u00E9tails, reportez-vous \u00E0 l''exception suivante. 

# Arguments:
#
#    {0} = moduleName
#
XBM02.D=Echec du d\u00E9marrage en raison d''une fonctionnalit\u00E9 manquante pour {0}. Assurez-vous que le chemin de classe contient les logiciels Derby appropri\u00E9s.

# Arguments:
#
#    {0} = productName
#
XBM05.D=Echec du d\u00E9marrage en raison d''informations absentes sur la version du produit pour {0}.

XBM06.D=Echec du d\u00E9marrage. Il est impossible d''acc\u00E9der \u00E0 une base de donn\u00E9es crypt\u00E9e sans le mot de passe d''amor\u00E7age correct.  

XBM07.D=Echec du d\u00E9marrage. Le mot de passe d''amor\u00E7age doit avoir une longueur maximale de huit octets.

# Arguments:
#
#    {0} = subSubProtocol
#    {1} = className
#
XBM08.D=Impossible d''instancier la classe {0} StorageFactory {1}.

# Arguments:
#
#    {0} = directoryName
#    {1} = servicePropertiesName
#
XBM0A.D=Le r\u00E9pertoire de base de donn\u00E9es ''{0}'' existe. Cependant, il ne contient pas le fichier ''{1}'' attendu. Derby a peut-\u00EAtre \u00E9t\u00E9 interrompu lors de la cr\u00E9ation de cette base de donn\u00E9es. Supprimez ce r\u00E9pertoire et essayez de nouveau de cr\u00E9er la base de donn\u00E9es.

# Arguments:
#
#    {0} = errorMessage
#
XBM0B.D=Echec de la modification/l''\u00E9criture du fichier de propri\u00E9t\u00E9s de service : {0}

# Arguments:
#
#    {0} = operation
#    {1} = path
#    {2} = errorMessage
#
XBM0C.D=Privil\u00E8ge manquant pour l''op\u00E9ration ''{0}'' sur le fichier ''{1}'' : {2}

XBM0G.D=Echec du d\u00E9marrage du moteur de cryptage. Assurez-vous que vous ex\u00E9cutez Java 2, que vous avez t\u00E9l\u00E9charg\u00E9 un fournisseur de cryptage tel que jce et que vous l''avez plac\u00E9 dans le chemin de classe. 

# Arguments:
#
#    {0} = directoryName
#
XBM0H.D=Impossible de cr\u00E9er le r\u00E9pertoire {0}.

# Arguments:
#
#    {0} = directoryName
#
XBM0I.D=Impossible de retirer le r\u00E9pertoire {0}.

# Arguments:
#
#    {0} = directoryName
#
XBM0J.D=Le r\u00E9pertoire {0} existe d\u00E9j\u00E0.

# Arguments:
#
#    {0} = databaseName
#
XBM0K.D=Sous-protocole inconnu pour le nom de la base de donn\u00E9es {0}.

# Arguments:
#
#    {0} = className
#    {1} = interfaceName
#
XBM0L.D=La classe de mod\u00E8le d''authentification sp\u00E9cifi\u00E9e {0} n''impl\u00E9mente pas l''interface d''authentification {1}.

# Arguments:
#
#    {0} = className
#    {1} = detail
#
XBM0M.D=Erreur lors de la cr\u00E9ation d''une instance de la classe nomm\u00E9e ''{0}''. Ce nom de classe correspond \u00E0 la valeur de la propri\u00E9t\u00E9 derby.authentication.provider et doit \u00EAtre le nom d''une impl\u00E9mentation fournie par l''application de org.apache.derby.authentication.UserAuthenticator. Probl\u00E8me sous-jacent : {1}

XBM0N.D=Echec de l''inscription du pilote JDBC aupr\u00E8s de java.sql.DriverManager. Pour plus de d\u00E9tails, reportez-vous \u00E0 l''exception suivante. 

XBM0P.D=Le fournisseur de services est en lecture seule. L''op\u00E9ration n''est pas autoris\u00E9e. 

# Arguments:
#
#    {0} = fileName
#
XBM0Q.D=Fichier {0} introuvable. Assurez-vous que la copie de sauvegarde est correcte et qu''elle n''est pas endommag\u00E9e.

# Arguments:
#
#    {0} = fileName
#
XBM0R.D=Impossible de retirer le fichier {0}.  

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0S.D=Impossible de renommer le fichier ''{0}'' en ''{1}''

# Arguments:
#
#    {0} = databaseName
#
XBM0T.D=Sous-protocole ambigu pour le nom de la base de donn\u00E9es {0}.   

# Arguments:
#
#    {0} = identifierName
#
XBM0U.S=Aucune classe n''a \u00E9t\u00E9 inscrite pour l''identificateur {0}.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0V.S=Une exception a \u00E9t\u00E9 \u00E9mise lors du chargement de la classe {1} inscrite pour l''identificateur {0}.

# Arguments:
#
#    {0} = identifierName
#    {1} = className
#
XBM0W.S=Une exception a \u00E9t\u00E9 \u00E9mise lors de la cr\u00E9ation d''une instance de la classe {1} inscrite pour l''identificateur {0}.

# Arguments:
#
#    {0} = territoryID
#
XBM0X.D=La description de territoire fournie ''{0}'' n''est pas valide ; ln[_CO[_variant]] doit \u00EAtre indiqu\u00E9\nln=code de langue ISO-639 en minuscules et en deux lettres, CO=codes pays ISO-3166 en majuscules et en deux lettres, consultez java.util.Locale.

# Arguments:
#
#    {0} = collationName
#
XBM03.D=La valeur ''{0}'' fournie pour l''attribut de classement n''est pas valide, la valeur attendue \u00E9tant UCS_BASIC ou TERRITORY_BASED.

# Arguments:
#
#    {0} = localeName
#
XBM04.D=La prise en charge de la fonction de classement n''est pas disponible \u00E0 partir de la JVM pour les param\u00E8tres r\u00E9gionaux de la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = directoryName
#
XBM0Y.D=Le r\u00E9pertoire de sauvegarde de la base de donn\u00E9es {0} est introuvable. Assurez-vous que le chemin de sauvegarde indiqu\u00E9 est correct.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XBM0Z.D=Impossible de copier le fichier ''{0}'' dans ''{1}''. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00E8s sont corrects. 

# Arguments:
#
#    {0} = operationName
#
XCL01.S=L''ensemble de r\u00E9sultats ne renvoie pas de lignes. L''op\u00E9ration {0} n''est pas autoris\u00E9e. 

# Arguments:
#
#    {0} = operationName
#
XCL05.S=L''activation est ferm\u00E9e, l''op\u00E9ration {0} n''est pas autoris\u00E9e.

# Arguments:
#
#    {0} = cursorName
#
XCL07.S=Le curseur ''{0}'' est ferm\u00E9. V\u00E9rifiez que la fonction de validation automatique est d\u00E9sactiv\u00E9e.

# Arguments:
#
#    {0} = cursorName
#
XCL08.S=Le curseur ''{0}'' ne se trouve pas sur une ligne.

# Arguments:
#
#    {0} = methodName
#
XCL09.S=Une activation qui ne correspond pas \u00E0 PreparedStatement a \u00E9t\u00E9 transmise \u00E0 la m\u00E9thode ''{0}''.

XCL10.S=L''instruction PreparedStatement a \u00E9t\u00E9 recompil\u00E9e et les param\u00E8tres ont \u00E9t\u00E9 modifi\u00E9s. Si vous utilisez JDBC, vous devez repr\u00E9parer l''instruction.  

# Arguments:
#
#    {0} = datatypeName
#    {1} = datatypeName
#
XCL12.S=Une tentative de placement d''une valeur de donn\u00E9es de type ''{0}'' dans une valeur de donn\u00E9es de type ''{1}'' a \u00E9t\u00E9 effectu\u00E9e.

# Arguments:
#
#    {0} = parameterPosition
#    {1} = number
#
XCL13.S=La position de param\u00E8tre ''{0}'' est en dehors des limites. Le nombre de param\u00E8tres pour cette instruction pr\u00E9par\u00E9e est ''{1}''.

# Arguments:
#
#    {0} = columnPosition
#    {1} = number
#
XCL14.S=La position de colonne ''{0}'' est en dehors des limites. Le nombre de colonnes de ce ResultSet est ''{1}''.

# Arguments:
#
#    {0} = object
#    {1} = className
#
XCL15.S=Une exception ClassCastException s''est produite lors de l''appel de la m\u00E9thode compareTo() sur un objet ''{0}''. Le param\u00E8tre pour compareTo() est celui de la classe ''{1}''.

# Arguments:
#
#    {0} = operation
#
XCL16.S=ResultSet n''est pas ouvert. Op\u00E9ration ''{0}'' non autoris\u00E9e. V\u00E9rifiez que la validation automatique est d\u00E9sactiv\u00E9e.

XCL18.S=Impossible d''extraire le flux ou la valeur LOB plusieurs fois

# Arguments:
#
#    {0} = tableName
#    {1} = key
#
XCL19.S=Ligne manquante dans la table ''{0}'' pour la cl\u00E9 ''{1}''.

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL20.S=Les catalogues dont le niveau de version est ''{0}'' ne peuvent pas \u00EAtre mis \u00E0 niveau vers le niveau de version ''{1}''.

XCL21.S=Vous tentez d''ex\u00E9cuter une instruction de d\u00E9finition de donn\u00E9es (CREATE, DROP ou ALTER) tandis que vous pr\u00E9parez une instruction diff\u00E9rente. Cette op\u00E9ration n''est pas autoris\u00E9e. Cette situation peut se produire si vous ex\u00E9cutez une instruction de d\u00E9finition de donn\u00E9es \u00E0 partir d''un initialiseur statique d''une classe Java en cours d''utilisation depuis une instruction SQL.

# Arguments:
#
#    {0} = parameterName
#
XCL22.S=Le param\u00E8tre {0} ne peut pas \u00EAtre inscrit en tant que param\u00E8tre OUT car il s''agit d''un param\u00E8tre IN. 

# Arguments:
#
#    {0} = type
#
XCL23.S=Le type SQL num\u00E9ro ''{0}'' n''est pas un type pris en charge par registerOutParameter().

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#
XCL24.S=Le param\u00E8tre {0} semble \u00EAtre un param\u00E8tre de sortie, mais il n''a pas \u00E9t\u00E9 d\u00E9sign\u00E9 ainsi par registerOutParameter(). S''il ne s''agit pas d''un param\u00E8tre de sortie, il doit \u00EAtre d\u00E9fini sur le type {1}.

# Arguments:
#
#    {0} = parameterName
#    {1} = type
#    {2} = type
#
XCL25.S=Le param\u00E8tre {0} ne peut pas \u00EAtre inscrit avec le type {1} car il est mis en correspondance avec le type {2} et ils sont incompatibles.

# Arguments:
#
#    {0} = parameterName
#
XCL26.S=Le param\u00E8tre {0} n''est pas un param\u00E8tre de sortie.

XCL27.S=Les param\u00E8tres de sortie en renvoi ne peuvent pas \u00EAtre d\u00E9finis.

# Arguments:
#
#    {0} = dataType
#
XCL30.S=Une exception IOException a \u00E9t\u00E9 \u00E9mise lors de la lecture d''un \u00E9l\u00E9ment ''{0}'' \u00E0 partir d''InputStream.

XCL31.S=Instruction ferm\u00E9e.

# Arguments:
#
#    {0} = tableName
#
XCL33.S=La table ne peut pas \u00EAtre d\u00E9finie comme \u00E9tant d\u00E9pendante de la table {0} en raison des limitations de r\u00E8gle de suppression. (La relation est auto-r\u00E9f\u00E9renc\u00E9e et ce type de relation est d\u00E9j\u00E0 associ\u00E9 \u00E0 la r\u00E8gle de suppression SET NULL.) 

# Arguments:
#
#    {0} = tableName
#
XCL34.S=La table ne peut pas \u00EAtre d\u00E9finie comme \u00E9tant d\u00E9pendante de la table {0} en raison des limitations de r\u00E8gle de suppression. La relation engendre un cycle de plusieurs tables qui \u00E9tablit une d\u00E9pendance en cas de suppression entre chaque table (toutes les autres r\u00E8gles de suppression du cycle sont CASCADE).  

# Arguments:
#
#    {0} = tableName
#
XCL35.S=La table ne peut pas \u00EAtre d\u00E9finie comme \u00E9tant d\u00E9pendante de la table {0} en raison des limitations de r\u00E8gle de suppression. (Dans le cadre de la relation, une d\u00E9pendance en cas de suppression s''\u00E9tablit entre cette table et la table indiqu\u00E9e en vertu de plusieurs relations et la r\u00E8gle de suppression de la relation existante est SET NULL.)  

# Arguments:
#
#    {0} = sqlText
#
XCL36.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re doit \u00EAtre {0}. La contrainte r\u00E9f\u00E9rentielle est auto-r\u00E9f\u00E9renc\u00E9e et une contrainte de ce type est d\u00E9j\u00E0 associ\u00E9e \u00E0 la r\u00E8gle de suppression indiqu\u00E9e (NO ACTION, RESTRICT ou CASCADE).

# Arguments:
#
#    {0} = sqlText
#
XCL37.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re doit \u00EAtre {0}. (La contrainte r\u00E9f\u00E9rentielle est auto-r\u00E9f\u00E9renc\u00E9e et la table est d\u00E9pendante dans le cadre d''une relation avec la r\u00E8gle de suppression CASCADE.)

# Arguments:
#
#    {0} = ruleName
#
XCL38.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re doit \u00EAtre {0}. Dans le cadre de la relation, une d\u00E9pendance en cas de suppression est \u00E9tablie entre cette table et une table identique en vertu de plusieurs relations qui doivent \u00EAtre associ\u00E9es \u00E0 la m\u00EAme r\u00E8gle de suppression (NO ACTION, RESTRICT ou CASCADE). 

XCL39.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re ne peut pas \u00EAtre CASCADE. (Une contrainte auto-r\u00E9f\u00E9renc\u00E9e associ\u00E9e \u00E0 une r\u00E8gle de suppression SET NULL, NO ACTION ou RESTRICT existe d\u00E9j\u00E0.) 

XCL40.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re ne peut pas \u00EAtre CASCADE. (La relation engendre un cycle \u00E9tablissant une d\u00E9pendance en cas de suppression de la table avec elle-m\u00EAme. Si l''une des r\u00E8gles de suppression du cycle n''est pas CASCADE, cette relation peut \u00EAtre d\u00E9finie.) 

XCL41.S=La r\u00E8gle de suppression de la cl\u00E9 \u00E9trang\u00E8re ne peut pas \u00EAtre CASCADE. (Dans le cadre de la relation, une d\u00E9pendance en cas de suppression est \u00E9tablie entre une autre table et la m\u00EAme table par le biais de plusieurs chemins associ\u00E9s \u00E0 des r\u00E8gles de suppression diff\u00E9rentes ou \u00E0 une r\u00E8gle de suppression SET NULL.) 

# Arguments:
#
#    {0} = sqlText
#    {1} = versionNumber
#    {2} = versionNumber
#
XCL47.S=L''utilisation de ''{0}'' requiert que la base de donn\u00E9es soit mise \u00E0 niveau de la version {1} vers la version {2} ou ult\u00E9rieure.

# Arguments:
#
#    {0} = tableName
#
XCL48.S= L''instruction TRUNCATE TABLE n''est pas autoris\u00E9e sur ''{0}'' car les contraintes de cl\u00E9 unique/primaire sur cette table sont r\u00E9f\u00E9renc\u00E9es par des contraintes de cl\u00E9 \u00E9trang\u00E8re activ\u00E9es \u00E0 partir d''autres tables. 

# Arguments:
#
#    {0} = tableName
#    {1} = triggerName
#
XCL49.S= L''instruction TRUNCATE TABLE n''est pas autoris\u00E9e sur ''{0}'' car elle contient un d\u00E9clencheur DELETE activ\u00E9 ({1}).

# Arguments:
#
#    {0} = versionNumber
#    {1} = versionNumber
#
XCL50.S=La mise \u00E0 niveau de la base de donn\u00E9es \u00E0 partir d''une version ant\u00E9rieure n''est pas prise en charge. Le niveau de version de la base de donn\u00E9es est ''{0}'' et celui du logiciel est ''{1}''.    

XCL51.S=La fonction demand\u00E9e ne peut pas faire r\u00E9f\u00E9rence \u00E0 des tables du sch\u00E9ma SESSION.

XCL52.S=Cette instruction a \u00E9t\u00E9 annul\u00E9e ou temporis\u00E9e.

# Arguments:
#
#    {0} = versionID
#    {1} = versionID
#
XCW00.D=Mise \u00E0 niveau de ''{0}'' vers ''{1}'' non prise en charge.

XCXA0.S=Identificateur non valide.

# Arguments:
#
#    {0} = classpath
#
XCXB0.S=Chemin de classe de base de donn\u00E9es non valide : ''{0}''.

XCXC0.S=Liste d''ID non valide.

XCXE0.S=Vous tentez d''effectuer une op\u00E9ration qui utilise le territoire de la base de donn\u00E9es, mais cette derni\u00E8re ne poss\u00E8de aucun territoire.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY00.S=Valeur non valide pour la propri\u00E9t\u00E9 ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCY02.S=La modification de propri\u00E9t\u00E9 demand\u00E9e n''est pas prise en charge ''{0}''=''{1}''.

# Arguments:
#
#    {0} = propertyName
#
XCY03.S=La propri\u00E9t\u00E9 requise ''{0}'' n''a pas \u00E9t\u00E9 d\u00E9finie.

XCY04.S=Syntaxe non valide pour les substitutions d''optimiseur. La syntaxe doit \u00EAtre la suivante : -- DERBY-PROPERTIES propertyName = value [, propertyName = value]*

XCY05.S.2=Param\u00E8tre de la propri\u00E9t\u00E9 derby.authentication.provider non valide. Cette propri\u00E9t\u00E9 est d\u00E9j\u00E0 d\u00E9finie pour activer l''authentification NATIVE et ne peut pas \u00EAtre modifi\u00E9e.

XCY05.S.3=Param\u00E8tre de la propri\u00E9t\u00E9 derby.authentication.provider non valide. Pour activer l''authentification NATIVE, utilisez la proc\u00E9dure SYSCS_UTIL.SYSCS_CREATE_USER afin de stocker les informations d''identification et de connexion du propri\u00E9taire de la base de donn\u00E9es.

# Arguments:
#
#    {0} = permissionName
#
XCZ00.S=Droit d''acc\u00E8s inconnu ''{0}''.

# Arguments:
#
#    {0} = authorizationID
#
XCZ01.S=Utilisateur inconnu ''{0}''.

# Arguments:
#
#    {0} = propertyName
#    {1} = propertyValue
#
XCZ02.S=Param\u00E8tre non valide ''{0}''=''{1}''.

XD004.S=Impossible de stocker les d\u00E9pendances.

XIE01.S=Connexion NULL.

# Arguments:
#
#    {0} = lineNumber
#    {1} = columnName
#
XIE03.S=Donn\u00E9es trouv\u00E9es sur la ligne {0} pour la colonne {1} apr\u00E8s le d\u00E9limiteur d''arr\u00EAt.  

# Arguments:
#
#    {0} = fileName
#
XIE04.S=Fichier de donn\u00E9es introuvable : {0}

XIE05.S=Le fichier de donn\u00E9es ne peut pas \u00EAtre NULL. 

XIE06.S=Le nom de l''entit\u00E9 est NULL.

XIE07.S=Les s\u00E9parateurs de champ et d''enregistrement ne peuvent pas \u00EAtre des sous-cha\u00EEnes les uns des autres. 

# Arguments:
#
#    {0} = columnName
#
XIE08.S=Il n''existe aucune colonne nomm\u00E9e : {0}.  

# Arguments:
#
#    {0} = number
#
XIE09.S=Le nombre total de colonnes dans la ligne est : {0}.  

# Arguments:
#
#    {0} = columnName
#    {1} = type
#
XIE0B.S=La colonne ''{0}'' de la table est de type {1}, ce qui n''est pas pris en charge par les fonctions d''import et d''export.   

# Arguments:
#
#    {0} = lineNumber
#
XIE0D.S=S\u00E9parateur d''enregistrement introuvable sur la ligne {0}.

# Arguments:
#
#    {0} = lineNumber
#
XIE0E.S=Fin de fichier lue en un point inattendu de la ligne {0}.

XIE0I.S=Une exception IOException s''est produite lors de l''\u00E9criture de donn\u00E9es dans le fichier.

XIE0J.S=Un d\u00E9limiteur n''est pas valide ou est utilis\u00E9 plusieurs fois.

XIE0K.S=Le point a \u00E9t\u00E9 sp\u00E9cifi\u00E9 comme d\u00E9limiteur de cha\u00EEne de caract\u00E8res.

# Arguments:
#
#    {0} = tableName
#
XIE0M.S=La table ''{0}'' n''existe pas.  

# Arguments:
#
#    {0} = hexString
#
XIE0N.S=Une cha\u00EEne hexad\u00E9cimale non valide ''{0}'' a \u00E9t\u00E9 d\u00E9tect\u00E9e dans le fichier d''import.

# Arguments:
#
#    {0} = fileName
#
XIE0P.S=Le fichier de donn\u00E9es LOB {0} r\u00E9f\u00E9renc\u00E9 dans le fichier d''import est introuvable.

XIE0Q.S=Le nom du fichier de donn\u00E9es LOB ne peut pas \u00EAtre NULL. 

# Arguments:
#
#    {0} = lineNumber
#    {1} = fileName
#    {2} = details
#
XIE0R.S=Erreur d''import sur la ligne {0} du fichier {1} : {2} 

# Arguments:
#
#    {0} = fileName
#
XIE0S.S=L''op\u00E9ration d''export n''a pas \u00E9t\u00E9 effectu\u00E9e, car le fichier de sortie sp\u00E9cifi\u00E9 ({0}) existe d\u00E9j\u00E0. Pour des raisons de s\u00E9curit\u00E9 et pour \u00E9viter tout risque accidentel de dommage sur un fichier, la proc\u00E9dure d''export n''\u00E9crase pas un fichier existant, m\u00EAme si le processus dispose des droits d''acc\u00E8s en \u00E9criture sur le fichier en question. Soit vous modifiez le nom du fichier de sortie dans les arguments de la proc\u00E9dure d''export afin qu''il soit unique, soit vous supprimez le fichier existant avant de recommencer l''op\u00E9ration d''export.

# Arguments:
#
#    {0} = fileName
#
XIE0T.S=L''op\u00E9ration d''export n''a pas \u00E9t\u00E9 effectu\u00E9e, car le fichier auxiliaire LOB sp\u00E9cifi\u00E9 ({0}) existe d\u00E9j\u00E0. Pour des raisons de s\u00E9curit\u00E9 et pour \u00E9viter tout risque accidentel de dommage sur un fichier, la proc\u00E9dure d''export n''\u00E9crase pas un fichier existant, m\u00EAme si le processus dispose des droits d''acc\u00E8s en \u00E9criture sur le fichier en question. Soit vous modifiez le nom du fichier auxiliaire LOB dans les arguments de la proc\u00E9dure d''export afin qu''il soit unique, soit vous supprimez le fichier existant avant de recommencer l''op\u00E9ration d''export.

# Arguments:
#
#    {0} = databaseName
#
XJ004.C=Base de donn\u00E9es ''{0}'' introuvable.

XJ008.S=Impossible d''annuler (rollback) ou de lib\u00E9rer un point de sauvegarde en mode de validation automatique.

# Arguments:
#
#    {0} = sqlText
#
XJ009.S=Utilisation de CallableStatement requise pour un appel de proc\u00E9dure stock\u00E9e ou l''utilisation de param\u00E8tres de sortie : {0}

XJ010.S=Impossible de g\u00E9n\u00E9rer un SAVEPOINT lorsque autoCommit est activ\u00E9e.

XJ011.S=Impossible de transmettre une valeur NULL comme nom de SAVEPOINT.

# Arguments:
#
#    {0} = interfaceName
#
XJ012.S=''{0}'' est d\u00E9j\u00E0 ferm\u00E9.

XJ013.S=Aucun identificateur pour les \u00E9l\u00E9ments SAVEPOINTS nomm\u00E9s.

XJ014.S=Aucun nom pour les SAVEPOINTS dont le nom n''est pas indiqu\u00E9.

XJ015.M=Arr\u00EAt du syst\u00E8me Derby.

# Arguments:
#
#    {0} = methodName
#
XJ016.S=La m\u00E9thode ''{0}'' n''est pas autoris\u00E9e sur une instruction pr\u00E9par\u00E9e.

XJ017.S=Aucune commande savepoint autoris\u00E9e dans le code de d\u00E9clenchement.

XJ018.S=Le nom de colonne ne peut pas \u00EAtre NULL.

# Arguments:
#
#    {0} = typeName
#
XJ020.S=Le type d''objet n''est pas convertible vers le type ''{0}'', la valeur java.sql.Types est incorrecte ou l''objet est NULL.

XJ021.S=Ce type n''est pas pris en charge.

# Arguments:
#
#    {0} = name
#
XJ022.S=Impossible de d\u00E9finir le flux : ''{0}''.

XJ023.S=Le flux en entr\u00E9e ne comprenait pas exactement la m\u00EAme quantit\u00E9 de donn\u00E9es que la longueur requise.

XJ025.S=La longueur du flux en entr\u00E9e ne peut pas \u00EAtre n\u00E9gative.

# Arguments:
#
#    {0} = urlValue
#
XJ028.C=Le format de l''URL ''{0}'' n''est pas correct.

XJ030.S=Impossible d''activer la validation automatique dans une connexion imbriqu\u00E9e.

# Arguments:
#
#    {0} = databaseName
#    {1} = classLoader
#
XJ040.C=Echec du d\u00E9marrage de la base de donn\u00E9es ''{0}'' avec le chargeur de classe {1} ; pour plus de d\u00E9tails, consultez l''exception suivante.

# Arguments:
#
#    {0} = databaseName
#
XJ041.C=Echec de la cr\u00E9ation de la base de donn\u00E9es ''{0}'' ; pour plus de d\u00E9tails, consultez l''exception suivante.

# Arguments:
#
#    {0} = propertyValue
#    {1} = propertyName
#
XJ042.S=''{0}'' n''est pas une valeur valide pour la propri\u00E9t\u00E9 ''{1}''.

# Arguments:
#
#    {0} = number
#
XJ044.S=''{0}'' est une \u00E9chelle non valide.

# Arguments:
#
#    {0} = levelName
#
XJ045.S=Un niveau d''isolement non valide ou non pris en charge (actuellement) ''{0}'' a \u00E9t\u00E9 transmis \u00E0 Connection.setTransactionIsolation(). Les valeurs actuellement prises en charge sont java.sql.Connection.TRANSACTION_SERIALIZABLE, java.sql.Connection.TRANSACTION_REPEATABLE_READ, java.sql.Connection.TRANSACTION_READ_COMMITTED et java.sql.Connection.TRANSACTION_READ_UNCOMMITTED.

# Arguments:
#
#    {0} = attributes
#
XJ048.C=Conflit d''attributs d''amor\u00E7age sp\u00E9cifi\u00E9s : {0}

XJ049.C=Conflit d''''attributs de cr\u00E9ation sp\u00E9cifi\u00E9s.

XJ04B.S=Le batch ne peut pas contenir de commande tentant de renvoyer un ensemble de r\u00E9sultats.

XJ04C.S=Le batch CallableStatement ne peut pas contenir de param\u00E8tres de sortie.

XJ056.S=Impossible d''activer la validation automatique dans une connexion XA.

XJ057.S=Impossible de valider (commit) une transaction globale qui utilise la connexion ; le traitement de la validation doit passer par l''interface XAResource.

XJ058.S=Impossible d''annuler (rollback) une transaction globale qui utilise la connexion ; le traitement de la validation doit passer par l''interface XAResource.

XJ059.S=Impossible de fermer une connexion lorsqu''une transaction globale est toujours active.

# Arguments:
#
#    {0} = attributeName
#    {1} = attributeValue
#    {2} = attributeValues
#
XJ05B.C=L''attribut JDBC ''{0}'' a une valeur non valide ''{1}'' ; les valeurs valides sont ''{2}''.

XJ05C.S=Impossible de d\u00E9finir la fonction holdability ResultSet.HOLD_CURSORS_OVER_COMMIT pour une transaction globale.

# Arguments:
#
#    {0} = methodName
#
XJ061.S=La m\u00E9thode ''{0}'' est uniquement autoris\u00E9e sur les curseurs de d\u00E9filement.

# Arguments:
#
#    {0} = invalidNumber
#
XJ062.S=Valeur de param\u00E8tre non valide ''{0}'' pour ResultSet.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ063.S=Valeur de param\u00E8tre non valide ''{0}'' pour Statement.setMaxRows(int maxRows). La valeur du param\u00E8tre doit \u00EAtre >= 0.

# Arguments:
#
#    {0} = invalidNumber
#
XJ064.S=Valeur de param\u00E8tre non valide ''{0}'' pour setFetchDirection(int direction).

# Arguments:
#
#    {0} = invalidNumber
#
XJ065.S=Valeur de param\u00E8tre non valide ''{0}'' pour Statement.setFetchSize(int rows).

# Arguments:
#
#    {0} = invalidNumber
#
XJ066.S=Valeur de param\u00E8tre non valide ''{0}'' pour Statement.setMaxFieldSize(int max).

XJ067.S=Le pointeur de texte SQL est NULL.

XJ068.S=Seuls executeBatch et clearBatch sont autoris\u00E9s au milieu d''un batch.

XJ069.S=Aucune m\u00E9thode SetXXX autoris\u00E9e avec l''instruction d''ex\u00E9cution USING.

# Arguments:
#
#    {0} = argument
#
XJ070.S=Un argument de position n\u00E9gatif ou \u00E9gal \u00E0 z\u00E9ro ''{0}'' a \u00E9t\u00E9 transmis dans une m\u00E9thode BLOB ou CLOB.

# Arguments:
#
#    {0} = argument
#
XJ071.S=Un argument de longueur n\u00E9gatif ''{0}'' a \u00E9t\u00E9 transmis dans une m\u00E9thode BLOB ou CLOB.

XJ072.S=Un mod\u00E8le ou searchStr NULL a \u00E9t\u00E9 transmis dans une m\u00E9thode de position BLOB ou CLOB.

XJ073.S=Les donn\u00E9es de BLOB ou CLOB ne sont plus disponibles. La transaction BLOB/CLOB est peut \u00EAtre valid\u00E9e (commit), sa connexion est peut \u00EAtre ferm\u00E9e ou a \u00E9t\u00E9 lib\u00E9r\u00E9e.

# Arguments:
#
#    {0} = invalidNumber
#
XJ074.S=Valeur de param\u00E8tre non valide ''{0}'' pour Statement.setQueryTimeout(int seconds).

# Arguments:
#
#    {0} = positionArgument
#
XJ076.S=L''argument de position ''{0}'' d\u00E9passe la taille du BLOB/CLOB.

XJ077.S=Une exception s''est produite lors de la tentative de lecture du premier octet/caract\u00E8re du mod\u00E8le BLOB/CLOB \u00E0 l''aide de getBytes/getSubString.

# Arguments:
#
#    {0} = invalidNumber
#
XJ078.S=La position ''{0}'' est soit inf\u00E9rieure \u00E0 z\u00E9ro, soit trop importante pour le BLOB/CLOB en cours.

# Arguments:
#
#    {0} = number
#
XJ079.S=La longueur ''{0}'' indiqu\u00E9e d\u00E9passe la taille du BLOB/CLOB.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ080.S=L''instruction d''ex\u00E9cution USING a transmis {0} param\u00E8tres et non {1}.

XJ081.C=Des attributs de cr\u00E9ation/restauration/r\u00E9cup\u00E9ration en conflit ont \u00E9t\u00E9 sp\u00E9cifi\u00E9s.

# Arguments:
#
#    {0} = parameterValue
#    {1} = parameterName
#    {2} = methodName
#
XJ081.S=Valeur non valide ''{0}'' transmise en tant que param\u00E8tre ''{1}'' \u00E0 la m\u00E9thode ''{2}''

XJ085.S=Le flux a d\u00E9j\u00E0 \u00E9t\u00E9 lu et la fin du fichier atteinte, donc le flux ne peut pas \u00EAtre r\u00E9utilis\u00E9.

XJ086.S=Impossible d''appeler cette m\u00E9thode lorsque le curseur n''est pas sur la ligne d''insertion ou si l''acc\u00E8s simultan\u00E9 de cet objet ResultSet est CONCUR_READ_ONLY.

# Arguments:
#
#    {0} = pos
#    {1} = length
#
XJ087.S=La somme des valeurs position(''{0}'') et length(''{1}'') est sup\u00E9rieure \u00E0 la taille de l''objet LOB plus un.

XJ088.S=Op\u00E9ration non valide : m\u00E9thode wasNull() appel\u00E9e sans donn\u00E9es extraites.

XJ090.S=Param\u00E8tre incorrect : le calendrier est NULL.

# Arguments:
#
#    {0} = indexNumber
#
XJ091.S=Argument non valide : l''index de param\u00E8tre {0} n''est pas un param\u00E8tre OUT ou INOUT.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ093.S=La longueur de BLOB/CLOB, {0}, est trop importante. La longueur ne peut pas d\u00E9passer {1}.

XJ095.S=Echec de la tentative d''ex\u00E9cution d''une action privil\u00E9gi\u00E9e.

XJ097.S=Impossible d''annuler (rollback) ou de lib\u00E9rer un point de sauvegarde qui n''a pas \u00E9t\u00E9 cr\u00E9\u00E9 par cette connexion.

# Arguments:
#
#    {0} = keyValue
#
XJ098.S=La valeur des cl\u00E9s g\u00E9n\u00E9r\u00E9es automatiquement {0} n''est pas valide

XJ099.S=L''objet Reader/Stream ne contient pas de caract\u00E8re de longueur

XJ100.S=L''\u00E9chelle fournie par la m\u00E9thode registerOutParameter ne correspond pas \u00E0 la m\u00E9thode d''acc\u00E8s setter. Perte possible de pr\u00E9cision.

XJ103.S=Le nom de table ne peut pas \u00EAtre NULL

# Arguments:
#
#    {0} = invalidNumber
#
XJ104.S=La longueur de cl\u00E9 partag\u00E9e n''est pas valide : {0}.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XJ105.S=La longueur de la cl\u00E9 DES est incorrecte : longueur attendue {0}, longueur obtenue {1}.

XJ106.S=Pas de remplissage 

XJ107.S=Remplissage incorrect

XJ108.S=Taille de bloc interdite

XJ110.S=Le nom de la table principale ne peut pas \u00EAtre NULL

XJ111.S=Le nom de la table \u00E9trang\u00E8re ne peut pas \u00EAtre NULL

XJ112.S=Exception de s\u00E9curit\u00E9 rencontr\u00E9e : pour plus d''informations, consultez l''exception suivante.

# Arguments:
#
#    {0} = fileName
#    {1} = error
#
XJ113.S=Impossible d''ouvrir le fichier {0} : {1}

# Arguments:
#
#    {0} = cursorName
#
XJ114.S=Nom de curseur non valide ''{0}''

# Arguments:
#
#    {0} = invalidNumber
#
XJ115.S=Impossible d''ouvrir resultSet avec la fonction holdability demand\u00E9e {0}.

# Arguments:
#
#    {0} = number
#
XJ116.S=Impossible d''ajouter plus de {0} commandes \u00E0 un batch unique.

XJ117.S=Le traitement par batch des requ\u00EAtes n''est pas autoris\u00E9 par la conformit\u00E9 J2EE.

XJ118.S=Le traitement par batch des requ\u00EAtes est demand\u00E9 sur une instruction qui n''est pas une requ\u00EAte.

XJ121.S=Op\u00E9ration non valide \u00E0 l''emplacement actuel du curseur.

XJ122.S=Aucune m\u00E9thode updateXXX n''a \u00E9t\u00E9 appel\u00E9e sur cette ligne.

XJ123.S=Cette m\u00E9thode doit \u00EAtre appel\u00E9e pour mettre \u00E0 jour les valeurs de la ligne actuelle ou de la ligne d''insertion.

XJ124.S=La colonne ne peut pas \u00EAtre mise \u00E0 jour.

XJ125.S=Cette m\u00E9thode doit \u00EAtre appel\u00E9e uniquement sur les objets ResultSet avec d\u00E9filement (type TYPE_SCROLL_INSENSITIVE).

XJ126.S=Cette m\u00E9thode ne doit pas \u00EAtre appel\u00E9e sur les curseurs dynamiques sensibles.

# Arguments:
#
#    {0} = interfaceName
#
XJ128.S=D\u00E9sencapsulation impossible pour ''{0}''

# Arguments:
#
#    {0} = number
#
XJ200.S=Nombre maximal de sections {0} d\u00E9pass\u00E9

# Arguments:
#
#    {0} = cursorName
#
XJ202.S=Nom de curseur non valide ''{0}''.

# Arguments:
#
#    {0} = cursorName
#
XJ203.S=Le nom de curseur ''{0}'' est d\u00E9j\u00E0 utilis\u00E9

# Arguments:
#
#    {0} = holdValue
#
XJ204.S=Impossible d''ouvrir l''ensemble de r\u00E9sultats avec la fonction holdability demand\u00E9e {0}.

# Arguments:
#
#    {0} = sqlText
#
XJ206.S=Le texte SQL ''{0}'' ne contient aucun jeton.

XJ207.S=La m\u00E9thode executeQuery ne peut pas \u00EAtre utilis\u00E9e pour la mise \u00E0 jour.

XJ208.S=Echec de batch d\u00E9composable. Le batch a \u00E9t\u00E9 soumis, mais au moins une exception s''est produite sur un membre individuel du batch. Utilisez la m\u00E9thode getNextException() pour extraire les exceptions pour des \u00E9l\u00E9ments sp\u00E9cifiques trait\u00E9s par batch.

XJ209.S=La proc\u00E9dure stock\u00E9e requise n''est pas install\u00E9e sur le serveur.

XJ210.S=Le nom du module de chargement pour la proc\u00E9dure stock\u00E9e sur le serveur est introuvable.

XJ211.S=Une exception de rupture de cha\u00EEne irr\u00E9cup\u00E9rable s''est produite au cours du traitement par batch. Le batch a \u00E9t\u00E9 interrompu de mani\u00E8re d\u00E9composable.

# Arguments:
#
#    {0} = attributeSyntax
#
XJ212.S=Syntaxe d''attribut non valide : {0}

XJ213.C=Le format d''un nombre de la propri\u00E9t\u00E9 de connexion traceLevel est incorrect.

XJ214.S=Une erreur d''E/S s''est produite lors de l''appel de m\u00E9thode free() sur un objet CLOB ou BLOB.

XJ215.S=Impossible d''appeler les autres m\u00E9thodes java.sql.Clob/java.sql.Blob apr\u00E8s avoir appel\u00E9 la m\u00E9thode free() ou apr\u00E8s avoir valid\u00E9 (commit) ou annul\u00E9 (rollback) la transaction BLOB/CLOB.

XJ216.S=La longueur de cet objet BLOB/CLOB n''est pas encore disponible. Lorsque vous acc\u00E9dez \u00E0 un objet BLOB ou CLOB en tant que flux, sa longueur est disponible uniquement apr\u00E8s le traitement complet du flux.

XJ217.S=Le localisateur fourni pour cet objet CLOB/BLOB n''est pas valide

# Arguments:
#
#    {0} = reason
#
XK000.S=Impossible de recharger la strat\u00E9gie de s\u00E9curit\u00E9 : {0}

XK001.S=Nom utilisateur introuvable dans SYS.SYSUSERS.

XN001.S=La r\u00E9initialisation de la connexion n''est pas autoris\u00E9e \u00E0 l''int\u00E9rieur d''une unit\u00E9 de travail.

XN008.S=Le traitement de la requ\u00EAte a \u00E9t\u00E9 arr\u00EAt\u00E9 en raison d''une erreur sur le serveur.

XN009.S=Erreur lors de l''obtention de la longueur de l''objet BLOB/CLOB, l''exception est la suivante.

XN010.S=Le nom de la proc\u00E9dure ne peut pas \u00EAtre NULL.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XN011.S=La longueur du nom de la proc\u00E9dure {0} ne se situe pas dans la plage valide comprise entre 1 et {1}.

# Arguments:
#
#    {0} = operatingSystemName
#    {1} = versionNumber
#    {2} = versionNumber
#
XN012.S=Sur les plates-formes {0}, XA prend en charge la version {1} et les versions ult\u00E9rieures ; il s''agit de la version {2}

XN013.S=Orientation de d\u00E9filement non valide.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN014.S=Une exception a \u00E9t\u00E9 d\u00E9tect\u00E9e lors de la lecture \u00E0 partir du flux sp\u00E9cifi\u00E9 par le param\u00E8tre #{0}. Les donn\u00E9es restantes attendues par le serveur ont \u00E9t\u00E9 remplies avec 0x0. L''exception pr\u00E9sente ce message : {1}.

# Arguments:
#
#    {0} = number
#
XN015.S=Erreur de protocole r\u00E9seau : la taille d\u00E9finie pour InputStream, param\u00E8tre n\u00B0{0}, est inf\u00E9rieure \u00E0 la longueur r\u00E9elle d''InputStream.

# Arguments:
#
#    {0} = number
#    {1} = messageText
#
XN016.S=Une exception a \u00E9t\u00E9 d\u00E9tect\u00E9e lors de la tentative de v\u00E9rification de la longueur du flux sp\u00E9cifi\u00E9 par le param\u00E8tre n\u00B0{0}. L''exception pr\u00E9sente ce message : {1}.

# Arguments:
#
#    {0} = number
#
XN017.S=La fin du flux a \u00E9t\u00E9 atteinte pr\u00E9matur\u00E9ment lors de la lecture du flux sp\u00E9cifi\u00E9 par le param\u00E8tre n\u00B0{0}. Les donn\u00E9es restantes attendues par le serveur ont \u00E9t\u00E9 remplies avec 0x0.

# Arguments:
#
#    {0} = number
#
XN018.S=Erreur de protocole r\u00E9seau : la taille d\u00E9finie de l''objet Reader, param\u00E8tre n\u00B0{0}, est inf\u00E9rieure \u00E0 la longueur r\u00E9elle d''InputStream.

# Arguments:
#
#    {0} = xaFunctionName
#    {1} = xaError
#
XN019.S=Erreur lors de l''ex\u00E9cution de {0}, le serveur a renvoy\u00E9 {1}.

# Arguments:
#
#    {0} = messageDetail
#
XN020.S=Une erreur s''est produite lors de la s\u00E9rialisation ou d\u00E9s\u00E9rialisation d''un type d\u00E9fini par l''utilisateur : {0}

# Arguments:
#
#    {0} = sourceClassName
#    {1} = targetClassName
#
XN021.S=Un objet de type {0} ne peut pas \u00EAtre converti en objet de type {1}.

XRE00=Ce module LogFactory ne prend pas en charge la r\u00E9plication.

XRE01=Le journal re\u00E7u du ma\u00EEtre est endommag\u00E9.

XRE02=Le ma\u00EEtre et l''esclave sont de versions diff\u00E9rentes. Impossible de poursuivre la r\u00E9plication.

XRE03=Erreur de r\u00E9plication inattendue. Pour plus d''informations, consultez le fichier derby.log.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = portname
#
XRE04.C.1=Impossible d''\u00E9tablir une connexion \u00E0 l''homologue de la base de donn\u00E9es r\u00E9pliqu\u00E9e ''{0}'' sur l''adresse ''{1}:{2}''.

# Arguments:
#
#    {0} = dbname
#
XRE04.C.2=Connexion perdue pour la base de donn\u00E9es r\u00E9pliqu\u00E9e ''{0}''.

# Arguments:
#
#    {0} = dbname
#    {1} = masterfile
#    {2} = masteroffset
#    {3} = slavefile
#    {4} = slaveoffset
#
XRE05.C=Les fichiers journaux sur le ma\u00EEtre et l''esclave ne sont pas synchronis\u00E9s pour la base de donn\u00E9es r\u00E9pliqu\u00E9e ''{0}''. L''instantan\u00E9 de journal ma\u00EEtre est {1}:{2}, alors que l''instantan\u00E9 de journal esclave est {3}:{4}. Ceci est fatal pour la r\u00E9plication : elle va \u00EAtre arr\u00EAt\u00E9e.

# Arguments:
#
#    {0} = dbname
#
XRE06=Les tentatives de connexion \u00E0 l''esclave de r\u00E9plication pour la base de donn\u00E9es {0} ont d\u00E9pass\u00E9 le d\u00E9lai d''attente sp\u00E9cifi\u00E9.

XRE07=Impossible d''ex\u00E9cuter l''op\u00E9ration car la base de donn\u00E9es n''est pas en mode ma\u00EEtre de r\u00E9plication.

# Arguments:
#
#    {0} = dbname
#
XRE08=Le mode esclave de r\u00E9plication a d\u00E9marr\u00E9 pour la base de donn\u00E9es ''{0}''. Connexion refus\u00E9e car la base de donn\u00E9es est en mode esclave de r\u00E9plication. 

# Arguments:
#
#    {0} = dbname
#
XRE09.C=Impossible de d\u00E9marrer le mode esclave de r\u00E9plication pour la base de donn\u00E9es ''{0}''. La base de donn\u00E9es a d\u00E9j\u00E0 \u00E9t\u00E9 amorc\u00E9e.

# Arguments:
#
#    {0} = attribute
#
XRE10=Conflit entre les attributs sp\u00E9cifi\u00E9s. Pour conna\u00EEtre les attributs autoris\u00E9s avec l''attribut de r\u00E9plication ''{0}'', consultez le manuel de r\u00E9f\u00E9rence.

# Arguments:
#
#    {0} = command
#    {1} = dbname
#
XRE11.C=Impossible d''ex\u00E9cuter l''op\u00E9ration ''{0}'' car la base de donn\u00E9es ''{1}'' n''a pas \u00E9t\u00E9 amorc\u00E9e.

# Arguments:
#
#    {0} = dbname
#    {1} = expectedtype
#    {2} = receivedtype
#
XRE12=Erreur du protocole r\u00E9seau de r\u00E9plication pour la base de donn\u00E9es ''{0}''. Type de message attendu ''{1}'', mais type re\u00E7u ''{2}''.

# Arguments:
#
#    {0} = dbname
#
XRE20.D=Basculement effectu\u00E9 pour la base de donn\u00E9es ''{0}'', la base de donn\u00E9es a \u00E9t\u00E9 ferm\u00E9e.

# Arguments:
#
#    {0} = dbname
#
XRE21.C=Une erreur s''est produite lors de l''ex\u00E9cution du basculement en cas d''incident pour la base de donn\u00E9es ''{0}''. Tentative de basculement abandonn\u00E9e.

# Arguments:
#
#    {0} = dbname
#
XRE22.C=Le ma\u00EEtre de r\u00E9plication a d\u00E9j\u00E0 \u00E9t\u00E9 amorc\u00E9 pour la base de donn\u00E9es ''{0}''

XRE23=Impossible de d\u00E9marrer le ma\u00EEtre de r\u00E9plication car des op\u00E9rations non enregistr\u00E9es sont en cours d''ex\u00E9cution. D\u00E9bloquez-le pour permettre aux op\u00E9rations non enregistr\u00E9es d''\u00EAtre ex\u00E9cut\u00E9es jusqu''au bout et red\u00E9marrez la r\u00E9plication.

XRE40=Impossible d''ex\u00E9cuter l''op\u00E9ration car la base de donn\u00E9es n''est pas en mode esclave de r\u00E9plication.

XRE41.C=Op\u00E9ration de r\u00E9plication ''failover'' ou ''stopSlave'' refus\u00E9e sur la base de donn\u00E9es esclave car la connexion avec le ma\u00EEtre fonctionne. Ex\u00E9cutez l''op\u00E9ration ''failover'' ou ''stopMaster'' sur la base de donn\u00E9es ma\u00EEtre.

# Arguments:
#
#    {0} = dbname
#
XRE42.C=Arr\u00EAt de la base de donn\u00E9es r\u00E9pliqu\u00E9e ''{0}''.

XRE43=Erreur inattendue lors de la tentative d''arr\u00EAt du mode esclave de r\u00E9plication. Pour arr\u00EAter le mode esclave de r\u00E9plication, utilisez l''op\u00E9ration ''stopSlave'' ou ''failover''.

# Arguments:
#
#    {0} = conglomerateNumber
#
XSAI2.S=L''agglom\u00E9ration ({0}) demand\u00E9e n''existe pas.

XSAI3.S=Fonctionnalit\u00E9 non impl\u00E9ment\u00E9e.

# Arguments:
#
#    {0} = interfaceName
#
XSAM0.S=Exception d\u00E9tect\u00E9e lors de la tentative d''amor\u00E7age du module pour ''{0}''.

# Arguments:
#
#    {0} = conglomID
#
XSAM2.S=Aucun index ni agglom\u00E9ration ayant pour ID d''agglom\u00E9ration ''{0}'' \u00E0 supprimer.

# Arguments:
#
#    {0} = conglomID
#
XSAM3.S=Aucun index ni agglom\u00E9ration ayant pour ID d''agglom\u00E9ration ''{0}''.

# Arguments:
#
#    {0} = sortName
#
XSAM4.S=Aucun tri nomm\u00E9 ''{0}''.

XSAM5.S=L''analyse doit \u00EAtre ouverte et positionn\u00E9e par un appel de la m\u00E9thode next() avant la lancement d''autres appels.

# Arguments:
#
#    {0} = containerName
#    {1} = pageNumber
#    {2} = recordNumber
#
XSAM6.S=L''enregistrement {2} de la page {1} du conteneur {0} est introuvable.

XSAS0.S=Une m\u00E9thode de l''interface de contr\u00F4leur d''analyse inappropri\u00E9e pour une analyse de tri a \u00E9t\u00E9 appel\u00E9e.

XSAS1.S=Une tentative d''extraction d''une ligne avant le d\u00E9but d''un tri ou apr\u00E8s la fin d''un tri a \u00E9t\u00E9 effectu\u00E9e.

XSAS3.S=Le type d''une ligne ins\u00E9r\u00E9e dans un tri ne correspond pas au mod\u00E8le du tri.

XSAS6.S=Impossible d''acqu\u00E9rir des ressources pour le tri.

XSAX0.S=Violation du protocole XA.

XSAX1.S=Une tentative de lancement d''une transaction globale avec le XID d''une transaction globale existante a \u00E9t\u00E9 effectu\u00E9e.

XSCB0.S=Impossible de cr\u00E9er un conteneur.

# Arguments:
#
#    {0} = containerName
#
XSCB1.S=Conteneur {0} introuvable.

# Arguments:
#
#    {0} = propertyName
#
XSCB2.S=La propri\u00E9t\u00E9 requise {0} est introuvable dans la liste de propri\u00E9t\u00E9s fournie \u00E0 createConglomerate() pour un index secondaire btree.

XSCB3.S=Fonctionnalit\u00E9 non impl\u00E9ment\u00E9e.

# Arguments:
#
#    {0} = number
#
XSCB4.S=Une m\u00E9thode sur une analyse d''ouverture btree a \u00E9t\u00E9 appel\u00E9e avant que l''analyse ne soit positionn\u00E9e sur la premi\u00E8re ligne (c''est-\u00E0-dire qu''aucun appel de next() n''a encore \u00E9t\u00E9 effectu\u00E9). L''\u00E9tat en cours de l''analyse est ({0}).

XSCB5.S=Au cours de l''annulation logique d''une insertion ou d''une suppression btree, la ligne n''a pas pu \u00EAtre trouv\u00E9e dans l''arborescence.

XSCB6.S=Restriction : l''enregistrement d''un index secondaire btree ne peut pas \u00EAtre mis \u00E0 jour ou ins\u00E9r\u00E9 en raison du manque d''espace sur la page. Utilisez les param\u00E8tres derby.storage.pageSize et/ou derby.storage.pageReservedSpace pour contourner cette restriction.

# Arguments:
#
#    {0} = trueOrFalse
#    {1} = trueOrFalse
#
XSCB7.S=Une erreur interne a \u00E9t\u00E9 d\u00E9tect\u00E9e au cours d''une analyse btree - current_rh est NULL = {0}, la cl\u00E9 de position est NULL = {1}.

# Arguments:
#
#    {0} = conglomerateNumber
#
XSCB8.S=L''agglom\u00E9ration btree {0} est ferm\u00E9e.

XSCB9.S=R\u00E9serv\u00E9 pour les tests.

XSCG0.S=Impossible de cr\u00E9er un mod\u00E8le.

XSCH0.S=Impossible de cr\u00E9er un conteneur.

# Arguments:
#
#    {0} = containerName
#
XSCH1.S=Conteneur {0} introuvable.

XSCH4.S=Impossible de cr\u00E9er une agglom\u00E9ration.

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSCH5.S=Dans une table de base, le num\u00E9ro de colonne demand\u00E9 {0} et le nombre maximal de colonnes {1} ne concordent pas.

# Arguments:
#
#    {0} = containerID
#
XSCH6.S=Le conteneur de portions de m\u00E9moire avec l''ID de conteneur {0} est ferm\u00E9.

XSCH7.S=L''analyse n''est pas positionn\u00E9e.

XSCH8.S=Fonctionnalit\u00E9 non impl\u00E9ment\u00E9e.

XSDA1.S=Une tentative d''acc\u00E8s \u00E0 un emplacement situ\u00E9 en dehors des limites d''une page a \u00E9t\u00E9 effectu\u00E9e

XSDA2.S=Une tentative de mise \u00E0 jour d''un enregistrement supprim\u00E9 a \u00E9t\u00E9 effectu\u00E9e

XSDA3.S=Restriction : l''enregistrement ne peut pas \u00EAtre mis \u00E0 jour ou ins\u00E9r\u00E9 en raison du manque d''espace sur la page. Utilisez les param\u00E8tres derby.storage.pageSize et/ou derby.storage.pageReservedSpace pour contourner cette restriction.

XSDA4.S=Une exception inattendue a \u00E9t\u00E9 \u00E9mise

XSDA5.S=Une tentative d''annulation de la suppression d''un enregistrement non supprim\u00E9 a \u00E9t\u00E9 effectu\u00E9e

# Arguments:
#
#    {0} = columnName
#
XSDA6.S=La colonne {0} de la ligne a la valeur NULL alors qu''elle doit d\u00E9signer un objet.

# Arguments:
#
#    {0} = className
#
XSDA7.S=La restauration d''un objet s\u00E9rialisable ou SQLData de classe {0} a tent\u00E9 de lire plus de donn\u00E9es que la quantit\u00E9 initialement stock\u00E9e

# Arguments:
#
#    {0} = className
#
XSDA8.S=Exception lors de la restauration d''un objet s\u00E9rialisable ou SQLData de la classe {0}

# Arguments:
#
#    {0} = className
#
XSDA9.S=Classe introuvable au cours de la restauration d''un objet s\u00E9rialisable ou SQLData de la classe {0}

# Arguments:
#
#    {0} = timestamp
#
XSDAA.S=Horodatage {0} non valide ; il provient soit d''une page diff\u00E9rente, soit d''une impl\u00E9mentation incompatible

XSDAB.S=Impossible de d\u00E9finir un horodatage NULL.

XSDAC.S=Tentative de d\u00E9placement de lignes ou de pages d''un conteneur \u00E0 un autre.

XSDAD.S=Tentative de d\u00E9placement de z\u00E9ro ligne d''une page vers une autre.

XSDAE.S=Descripteur d''enregistrement possible uniquement pour un ID de descripteur d''enregistrement sp\u00E9cial.

XSDAF.S=Utilisation d''un descripteur d''enregistrement sp\u00E9cial comme s''il s''agissait d''un descripteur d''enregistrement normal.

XSDAG.S=La premi\u00E8re transaction imbriqu\u00E9e de l''allocation ne peut pas ouvrir le conteneur.

# Arguments:
#
#    {0} = page
#
XSDAI.S=La page {0} en cours de retrait est d\u00E9j\u00E0 verrouill\u00E9e pour une suppression d''affectation.

XSDAJ.S=Exception au cours de l''\u00E9criture d''un objet s\u00E9rialisable ou SQLData

# Arguments:
#
#    {0} = recordHandle
#
XSDAK.S=La mauvaise page a \u00E9t\u00E9 extraite pour le descripteur d''enregistrement {0}.

# Arguments:
#
#    {0} = recordHandle
#
XSDAL.S=Le descripteur d''enregistrement {0} pointe de fa\u00E7on inattendue vers la page de d\u00E9passement.

# Arguments:
#
#    {0} = className
#
XSDAM.S=Une exception s''est produite au cours de la restauration d''un objet SQLData de la classe {0}. La classe indiqu\u00E9e ne peut pas \u00EAtre instanci\u00E9e.

# Arguments:
#
#    {0} = className
#
XSDAN.S=Une exception s''est produite au cours de la restauration d''un objet SQLData de la classe {0}. La classe indiqu\u00E9e a rencontr\u00E9 une exception d''acc\u00E8s interdit.

# Arguments:
#
#    {0} = pageNumber
#
XSDAO.S=Erreur interne : la page {0} a effectu\u00E9 deux tentatives de verrouillage.

# Arguments:
#
#    {0} = page
#
XSDB0.D=Exception inattendue sur la page en m\u00E9moire {0}

# Arguments:
#
#    {0} = page
#
XSDB1.D=Format de page inconnu \u00E0 la page {0}

# Arguments:
#
#    {0} = containerName
#    {1} = number
#
XSDB2.D=Format de conteneur inconnu au niveau du conteneur {0} : {1}

# Arguments:
#
#    {0} = number
#    {1} = number
#
XSDB3.D=Les informations relatives au conteneur ne peuvent pas \u00EAtre modifi\u00E9es une fois enregistr\u00E9es :  pr\u00E9c\u00E9demment {0}, d\u00E9sormais {1}

# Arguments:
#
#    {0} = page
#    {1} = versionNumber
#    {2} = versionNumber
#
XSDB4.D=La page {0} poss\u00E8de la version {1}, le fichier journal contient des modifications en version {2} ; soit des enregistrements de journal de cette page sont manquants, soit cette page n''a pas \u00E9t\u00E9 enregistr\u00E9e sur le disque correctement.

# Arguments:
#
#    {0} = page
#
XSDB5.D=Le fichier journal comprend un enregistrement de modification \u00E0 la page {0}, c''est-\u00E0-dire au-del\u00E0 de la fin du conteneur.

# Arguments:
#
#    {0} = databaseName
#
XSDB6.D=Il est possible qu''une autre instance de Derby ait d\u00E9j\u00E0 amorc\u00E9 la base de donn\u00E9es {0}.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB7.D=Avertissement : Derby (instance {0}) tente d''amorcer la base de donn\u00E9es {1} bien que Derby (instance {2}) soit peut-\u00EAtre encore actif. Une seule instance de Derby peut amorcer une base de donn\u00E9es \u00E0 la fois. Une alt\u00E9ration grave et irr\u00E9m\u00E9diable peut r\u00E9sulter de cette situation et s''est peut-\u00EAtre d\u00E9j\u00E0 produite.

# Arguments:
#
#    {0} = derbyInstanceID
#    {1} = databaseName
#    {2} = derbyInstanceID
#
XSDB8.D=Avertissement : Derby (instance {0}) tente d''amorcer la base de donn\u00E9es {1} m\u00EAme si Derby (instance {2}) est encore actif. Une seule instance de Derby peut initialiser une base de donn\u00E9es \u00E0 la fois. Une corruption importante et irr\u00E9versible peut se produire si 2 instances de Derby lancent l''amor\u00E7age de la m\u00EAme base de donn\u00E9es en m\u00EAme temps. La propri\u00E9t\u00E9 derby.database.forceDatabaseLock=true a \u00E9t\u00E9 d\u00E9finie, de sorte que la base de donn\u00E9es ne s''initialisera pas tant que db.lck est pr\u00E9sent. En r\u00E8gle g\u00E9n\u00E9rale, ce fichier est enlev\u00E9 lorsque la premi\u00E8re instance de Derby proc\u00E8de \u00E0 l''amor\u00E7age lors de la fermeture de la base de donn\u00E9es, mais dans certains cas il ne l''est pas. Il est alors n\u00E9cessaire de retirer le fichier manuellement. Il est important de v\u00E9rifier qu''aucune autre machine virtuelle n''acc\u00E8de \u00E0 la base de donn\u00E9es avant de supprimer le fichier db.lck manuellement.

# Arguments:
#
#    {0} = containerName
#
XSDB9.D=Le conteneur de flux {0} est endommag\u00E9.

# Arguments:
#
#    {0} = object
#
XSDBA.D=Echec de la tentative d''allocation de l''objet {0}.

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#
XSDBB.D=Format de page inconnu \u00E0 la page {0}, vidage de la page\u00A0: {1} 

# Arguments:
#
#    {0} = container
#
XSDBC.D=Echec de l''\u00E9criture des informations de conteneur sur la page 0 du conteneur {0}. Pour en savoir plus, reportez-vous \u00E0 l''erreur imbriqu\u00E9e.  

# Arguments:
#
#    {0} = fileName
#
XSDF0.S=Impossible de cr\u00E9er le fichier {0} car il existe d\u00E9j\u00E0.

# Arguments:
#
#    {0} = fileName
#
XSDF1.S=Exception lors de la cr\u00E9ation du fichier {0} pour le conteneur

# Arguments:
#
#    {0} = fileName
#    {1} = exceptionText
#
XSDF2.S=Exception lors de la cr\u00E9ation du fichier {0} pour le conteneur ; impossible d''enlever le fichier. Exception : {1}.

# Arguments:
#
#    {0} = segmentName
#
XSDF3.S=Impossible de cr\u00E9er le segment {0}.

# Arguments:
#
#    {0} = fileName
#    {1} = detailedException
#
XSDF4.S=Exception lors du retrait du fichier {0} pour le conteneur supprim\u00E9 ; impossible d''enlever le fichier {1}.

# Arguments:
#
#    {0} = page
#
XSDF6.S=Page d''allocation {0} introuvable.

# Arguments:
#
#    {0} = pageKey
#
XSDF7.S=Echec du verrouillage interne de la page nouvellement cr\u00E9\u00E9e {0}

# Arguments:
#
#    {0} = page
#
XSDF8.S=Impossible de trouver la page {0} \u00E0 r\u00E9utiliser.

XSDFB.S=Op\u00E9ration non prise en charge par une base de donn\u00E9es en lecture seule

# Arguments:
#
#    {0} = page
#    {1} = hexDump
#    {2} = hexDump
#
XSDFD.S=Diff\u00E9rentes lectures d''image de page lors de 2 E/S \u00E0 la page {0} ; la premi\u00E8re image pr\u00E9sente un total de contr\u00F4le incorrect, la deuxi\u00E8me image pr\u00E9sente un total de contr\u00F4le correct. Les images de page sont les suivantes : {1} {2}

XSDFF.S=Echec de l''op\u00E9ration demand\u00E9e en raison d''une exception inattendue.

# Arguments:
#
#    {0} = fileName
#
XSDFH.S=Impossible de sauvegarder la base de donn\u00E9es, une exception d''E/S s''est produite lors de l''\u00E9criture dans le fichier de conteneur de sauvegarde {0}.

# Arguments:
#
#    {0} = page
#
XSDFI.S=Erreur lors de la tentative d''\u00E9criture de donn\u00E9es sur le disque lors de la r\u00E9cup\u00E9ration de la base de donn\u00E9es. V\u00E9rifiez que le disque de base de donn\u00E9es n''est pas rempli. Si tel est le cas, effacez les fichiers superflus et retentez de vous connecter \u00E0 la base de donn\u00E9es. Il est \u00E9galement possible que le syst\u00E8me de fichiers soit en lecture seule, que le disque soit tomb\u00E9 en panne ou qu''un autre incident soit survenu sur le support. Le syst\u00E8me a rencontr\u00E9 une erreur lors du traitement de la page {0}.

# Arguments:
#
#    {0} = page
#
XSDG0.D=Impossible de lire la page {0} \u00E0 partir du disque.

# Arguments:
#
#    {0} = page
#
XSDG1.D=La page {0} n''a pas pu \u00EAtre \u00E9crite sur le disque ; v\u00E9rifiez que le disque n''est pas satur\u00E9 ou qu''aucune limite de syst\u00E8me de fichiers, notamment un quota ou une taille maximale de fichier, n''a \u00E9t\u00E9 atteinte.

# Arguments:
#
#    {0} = page
#    {1} = number
#    {2} = number
#    {3} = hexDump
#
XSDG2.D=Total de contr\u00F4le non valide dans la page {0}, valeur attendue = {1}, version sur disque = {2}, vidage de la page : {3}

# Arguments:
#
#    {0} = containerName
#    {1} = type
#    {2} = file
#
XSDG3.D=Impossible d''acc\u00E9der aux m\u00E9tadonn\u00E9es de {0} pour {1} {2}

XSDG5.D=La base de donn\u00E9es n''est pas en mode cr\u00E9ation lorsque createFinished est appel\u00E9.

# Arguments:
#
#    {0} = directoryPath
#
XSDG6.D=Le r\u00E9pertoire de segment de donn\u00E9es est introuvable dans la sauvegarde {0} pendant la restauration. Assurez-vous que la copie de sauvegarde est correcte et qu''elle n''est pas endommag\u00E9e.

# Arguments:
#
#    {0} = directoryName
#
XSDG7.D=Impossible d''enlever le r\u00E9pertoire {0} pendant la restauration. Assurez-vous que les droits d''acc\u00E8s sont corrects.

# Arguments:
#
#    {0} = directoryName
#    {1} = directoryName
#
XSDG8.D=Impossible de copier le r\u00E9pertoire ''{0}'' dans ''{1}'' lors de la restauration. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00E8s sont corrects. 

XSDG9.D=Le thread Derby a re\u00E7u une interruption lors d''une op\u00E9ration d''E/S du disque ; consultez votre application pour conna\u00EEtre la source de l''interruption.

# Arguments:
#
#    {0} = filePath
#
XSLA0.D=Impossible de vider le fichier journal sur le disque {0}.

# Arguments:
#
#    {0} = object
#
XSLA1.D=L''enregistrement de journal a \u00E9t\u00E9 envoy\u00E9 au flux, mais il ne peut pas \u00EAtre appliqu\u00E9 au stockage (objet {0}). Des probl\u00E8mes de r\u00E9cup\u00E9ration peuvent \u00E9galement en d\u00E9couler.

XSLA2.D=Le syst\u00E8me va \u00EAtre arr\u00EAt\u00E9 ; une exception d''E/S a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e lors de l''acc\u00E8s au fichier journal.

XSLA3.D=Fichier journal endommag\u00E9 ; des donn\u00E9es non valides se trouvent dans le flux de journalisation.

XSLA4.D=Erreur lorsque tentement d''\u00E9crire le journal de r\u00E9cup\u00E9ration de transaction. Tr\u00E8s probablement le disque contenant le journal de r\u00E9cup\u00E9ration est satur\u00E9. Si le disque est satur\u00E9, la seule possibilit\u00E9 de proc\u00E9der est lib\u00E9rer de l''espace sur le disque par son expansion ou par suppression de fichiers non li\u00E9s \u00E0 Derby. Il est \u00E9galement possible que le syst\u00E8me de fichiers et/ou le disque o\u00F9 r\u00E9side le journal de transaction de Derby soit en lecture seule. L''erreur peut \u00E9galement \u00EAtre produite si le disque ou le syst\u00E8me de fichiers soit tomb\u00E9 en panne.

# Arguments:
#
#    {0} = transactionID
#
XSLA5.D=Impossible de lire le flux de journalisation pour annuler (rollback) la transaction {0}.

XSLA6.D=Impossible de r\u00E9cup\u00E9rer la base de donn\u00E9es.

# Arguments:
#
#    {0} = operation
#
XSLA7.D=Impossible de r\u00E9p\u00E9ter l''op\u00E9ration {0} dans le journal.

# Arguments:
#
#    {0} = transactionID
#    {1} = undoableOperation
#    {2} = compensationOperation
#
XSLA8.D=Impossible d''annuler (rollback) la transaction {0} ; tentative de compensation de l''op\u00E9ration {1} par {2}

XSLAA.D=Une exception ant\u00E9rieure a marqu\u00E9 le stockage comme devant \u00EAtre arr\u00EAt\u00E9.

# Arguments:
#
#    {0} = logfileName
#
XSLAB.D=Le fichier journal {0} est introuvable ; assurez-vous que la propri\u00E9t\u00E9 logDevice est d\u00E9finie correctement avec le s\u00E9parateur de chemin d''acc\u00E8s appropri\u00E9 pour votre plate-forme.

# Arguments:
#
#    {0} = directoryPath
#
XSLAC.D=La base de donn\u00E9es situ\u00E9e dans {0} utilise un format incompatible avec la version actuelle du logiciel ; elle a peut-\u00EAtre \u00E9t\u00E9 cr\u00E9\u00E9e ou mise \u00E0 niveau par une version ult\u00E9rieure.

# Arguments:
#
#    {0} = length
#    {1} = length
#    {2} = logInstant
#    {3} = logfileName
#
XSLAD.D=L''enregistrement de journal \u00E0 l''instant {2} dans le fichier journal {3} est endommag\u00E9. La longueur pr\u00E9vue de l''enregistrement de journal est {0}, la longueur r\u00E9elle est {1}.

# Arguments:
#
#    {0} = fileName
#
XSLAE.D=Aucune \u00E9criture ou mise \u00E0 jour sur le fichier de contr\u00F4le situ\u00E9 dans {0} ne peut \u00EAtre effectu\u00E9e.

XSLAF.D=Une base de donn\u00E9es en lecture seule a \u00E9t\u00E9 cr\u00E9\u00E9e avec des m\u00E9moires tampon de donn\u00E9es non valides.

XSLAH.D=Une base de donn\u00E9es en lecture seule est en cours de mise \u00E0 jour.

XSLAI.D=Impossible de journaliser l''enregistrement de journal des points de reprise.

XSLAJ.D=A la suite d''un incident, le syst\u00E8me de journalisation est marqu\u00E9 comme devant \u00EAtre arr\u00EAt\u00E9 et aucune op\u00E9ration ne peut \u00EAtre ex\u00E9cut\u00E9e jusqu''\u00E0 l''arr\u00EAt et le red\u00E9marrage du syst\u00E8me.

# Arguments:
#
#    {0} = number
#
XSLAK.D=La base de donn\u00E9es a d\u00E9pass\u00E9 le plus grand num\u00E9ro de fichier journal {0}.

# Arguments:
#
#    {0} = logfileName
#    {1} = position
#    {2} = size
#    {3} = size
#
XSLAL.D=La taille de l''enregistrement de journal {2} d\u00E9passe la taille de fichier journal maximale autoris\u00E9e {3}. Erreur d\u00E9tect\u00E9e dans le fichier journal {0}, \u00E0 la position {1}.

# Arguments:
#
#    {0} = exceptionDetails
#    {1} = directoryPath
#
XSLAM.D=Impossible de v\u00E9rifier le format de la base de donn\u00E9es situ\u00E9e dans {1} en raison d''une exception d''E/S : {0}

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAN.D=La base de donn\u00E9es situ\u00E9e dans {0} utilise un format incompatible avec la version actuelle du logiciel. La base de donn\u00E9es a \u00E9t\u00E9 cr\u00E9\u00E9e ou mise \u00E0 niveau par la version {1}.

# Arguments:
#
#    {0} = detailedMessage
#
XSLAO.D=Echec de la r\u00E9cup\u00E9ration, probl\u00E8me inattendu {0}.

# Arguments:
#
#    {0} = directoryPath
#    {1} = versionNumber
#
XSLAP.D=La version de la base de donn\u00E9es {0} est {1}. Les bases de donn\u00E9es B\u00EAta ne peuvent pas \u00EAtre mises \u00E0 niveau.

# Arguments:
#
#    {0} = directoryName
#
XSLAQ.D=Impossible de cr\u00E9er un fichier journal dans le r\u00E9pertoire {0}.

# Arguments:
#
#    {0} = logfileName
#    {1} = logFileName
#
XSLAR.D=Impossible de copier le fichier journal ''{0}'' dans ''{1}'' lors de la restauration. Assurez-vous que l''espace est suffisant et que les droits d''acc\u00E8s sont corrects. 

# Arguments:
#
#    {0} = directoryName
#
XSLAS.D=Le r\u00E9pertoire de journal {0} est introuvable dans la sauvegarde lors de la restauration. Assurez-vous que la copie de sauvegarde est correcte et qu''elle n''est pas endommag\u00E9e.

# Arguments:
#
#    {0} = directoryName
#
XSLAT.D=Le r\u00E9pertoire de journal ''{0}'' existe. Ce r\u00E9pertoire fait peut-\u00EAtre partie d''une autre base de donn\u00E9es. Assurez-vous que l''emplacement indiqu\u00E9 pour l''attribut logDevice est correct.

# Arguments:
#
#    {0} = logOperation
#
XSLB1.S=L''op\u00E9ration de journal {0} rencontre une erreur lors de son enregistrement dans le flux de journalisation ; cela peut \u00EAtre d\u00FB \u00E0 une op\u00E9ration de journalisation errante ou \u00E0 la saturation de la m\u00E9moire tampon du journal interne suite \u00E0 une op\u00E9ration de journalisation trop volumineuse.

# Arguments:
#
#    {0} = logOperation
#
XSLB2.S=L''op\u00E9ration de journal {0} enregistre trop de donn\u00E9es ; elle a satur\u00E9 la m\u00E9moire tampon du journal interne.

# Arguments:
#
#    {0} = logInstant
#    {1} = truncationPoint
#    {2} = logInstant
#    {3} = logInstant
#
XSLB5.S=Instant truncationLWM {1} interdit pour le point de troncature {0}. La plage autoris\u00E9e est comprise entre {2} et {3}.

XSLB6.S=Tentative de journalisation d''un enregistrement de longueur 0 ou -ve.

# Arguments:
#
#    {0} = logInstant
#    {1} = logInstant
#
XSLB8.S=Tentative de r\u00E9initialisation d''une analyse sur {0}, au-del\u00E0 de sa limite de {1}.

XSLB9.S=Impossible d''\u00E9mettre d''autres modifications ; la fabrique de journaux a \u00E9t\u00E9 arr\u00EAt\u00E9e.

XSRS0.S=Impossible de bloquer la base de donn\u00E9es lorsqu''elle a d\u00E9j\u00E0 \u00E9t\u00E9 bloqu\u00E9e.

# Arguments:
#
#    {0} = directoryPath
#
XSRS1.S=Impossible de sauvegarder la base de donn\u00E9es dans {0} car il ne s''agit pas d''un r\u00E9pertoire.

# Arguments:
#
#    {0} = fileName
#    {1} = fileName
#
XSRS4.S=Erreur lors du changement de nom du fichier (lors de la sauvegarde) de {0} vers {1}.

# Arguments:
#
#    {0} = path
#    {1} = path
#
XSRS5.S=Erreur lors de la copie du fichier (lors de la sauvegarde) de {0} vers {1}.

# Arguments:
#
#    {0} = directoryName
#
XSRS6.S=Impossible de cr\u00E9er le r\u00E9pertoire de sauvegarde {0}.

XSRS7.S=La sauvegarde a d\u00E9tect\u00E9 une exception inattendue.

XSRS8.S=L''unit\u00E9 de journalisation peut uniquement \u00EAtre d\u00E9finie au cours du processus de cr\u00E9ation de la base de donn\u00E9es ; elle ne peut pas \u00EAtre modifi\u00E9e \u00E0 la vol\u00E9e.

# Arguments:
#
#    {0} = recordName
#
XSRS9.S=L''enregistrement {0} n''existe plus

XSRSA.S=Impossible de sauvegarder la base de donn\u00E9es lorsque des op\u00E9rations non journalis\u00E9es ne sont pas valid\u00E9es (commit). Validez les transactions contenant des op\u00E9rations qui bloquent la sauvegarde. 

XSRSB.S=Impossible de sauvegarder une transaction contenant des op\u00E9rations non journalis\u00E9es et non valid\u00E9es (commit).

# Arguments:
#
#    {0} = directoryLocation
#
XSRSC.S=Impossible de sauvegarder la base de donn\u00E9es dans {0} car il s''agit d''un r\u00E9pertoire de base de donn\u00E9es.

XSTA2.S=Une transaction \u00E9tait d\u00E9j\u00E0 active lorsqu''une tentative d''activation d''une autre transaction a \u00E9t\u00E9 effectu\u00E9e.

XSTB0.M=Une exception a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e lors de l''abandon de la transaction.

XSTB2.M=Impossible de journaliser les modifications de transaction ; il s''agit peut-\u00EAtre d''une tentative d''\u00E9criture dans une base de donn\u00E9es en lecture seule.

XSTB3.M=Impossible d''abandonner la transaction car le gestionnaire des journaux est NULL, probablement en raison d''une erreur ant\u00E9rieure.

XSTB5.M=Un incident inattendu s''est produit lors la cr\u00E9ation d''une base de donn\u00E9es pour laquelle la journalisation est d\u00E9sactiv\u00E9e.

XSTB6.M=Impossible de remplacer une table de transactions par une autre tant qu''une table est d\u00E9j\u00E0 en cours d''utilisation.

XXXXX.C.6=La session de base de donn\u00E9es normale est ferm\u00E9e.

02000=Aucune ligne n''a \u00E9t\u00E9 trouv\u00E9e pour FETCH, UPDATE ou DELETE ou le r\u00E9sultat d''une requ\u00EAte est une table vide.

# Arguments:
#
#    {0} = operatorName
#    {1} = detailedError
#
10000=Une erreur a \u00E9t\u00E9 rencontr\u00E9e lors de l''\u00E9valuation de l''expression de requ\u00EAte XML pour l''op\u00E9rateur {0} : {1}

42Z00.U=Appel de m\u00E9thode Java ou r\u00E9f\u00E9rence de champ

42Z01.U=Sans type

# Arguments:
#
#    {0} = javaClassName
#
42Z10=La classe Java li\u00E9e \u00E0 un type d\u00E9fini par l''utilisateur n''est peut-\u00EAtre pas une classe utilis\u00E9e en interne par Derby : ''{0}''.

# Arguments:
#
#    {0} = dataType
#
42Z12.U=Erreur interne : tentative non valide d''acc\u00E8s \u00E0 un \u00E9l\u00E9ment {0} en tant que flux

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z30.U=temps pass\u00E9 dans ce ResultSet =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z31.U=temps pass\u00E9 dans ce ResultSet et en dessous =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z32.U=r\u00E9partition de la dur\u00E9e totale : 

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z33.U=dur\u00E9e du constructeur (millisecondes) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z34.U=dur\u00E9e d''ouverture (millisecondes) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z35.U=dur\u00E9e next (millisecondes) =

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z36.U=dur\u00E9e de fermeture (millisecondes) =

# Translators: This is part of query plan printout; the string is complete as is.
# This is a start or stop position for a scan.
#
42Z37.U=Aucun

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z38.U=Aucune information de positionnement n''est disponible car ce ResultSet n''a jamais \u00E9t\u00E9 ouvert.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = exceptionMessage
#
42Z39.U=Exception inattendue {0} lors de l''obtention du positionneur.

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = searchOperator
#    {1} = number
#
42Z40.U={0} sur les {1} premi\u00E8res colonnes.

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z41.U=S\u00E9mantique des valeurs NULL ordonn\u00E9es dans les colonnes suivantes : 

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z42.U=ID de colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z43.U=Op\u00E9rateur

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z44.U=Valeurs NULL ordonn\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z45.U=Valeur de retour inconnue

# Translators: This is part of query plan printout; the string is complete as is.
#
42Z46.U=Inverser la fen\u00EAtre des r\u00E9sultats de la comparaison

# Arguments:
#
#    {0} = className
#
42Z47.U=L''obtention du plan de requ\u00EAte sous forme de cha\u00EEne n''est pas prise en charge actuellement pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = term
#    {1} = columnNumber
#
42Z48.U=ID de colonne[{0}][{1}]

42Z54.U=Cette exception arr\u00EAte l''instruction apr\u00E8s l''analyse. Aucun autre traitement n''est requis.

42Z55.U=L''ex\u00E9cution a \u00E9t\u00E9 arr\u00EAt\u00E9e apr\u00E8s l''analyse par l''indicateur de d\u00E9bogage StopAfterParsing.

42Z56.U=L''ex\u00E9cution a \u00E9t\u00E9 arr\u00EAt\u00E9e apr\u00E8s la liaison par l''indicateur de d\u00E9bogage StopAfterBinding.

42Z57.U=L''ex\u00E9cution a \u00E9t\u00E9 arr\u00EAt\u00E9e apr\u00E8s l''optimisation par l''indicateur de d\u00E9bogage StopAfterOptimizing.

42Z58.U=L''ex\u00E9cution a \u00E9t\u00E9 arr\u00EAt\u00E9e apr\u00E8s la g\u00E9n\u00E9ration par l''indicateur de d\u00E9bogage StopAfterGenerating.

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z80.U=s\u00E9rialisable

# A transaction isolation level. See http://en.wikipedia.org/wiki/Isolation_%28database_systems%29
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z81.U=lecture valid\u00E9e (commit)

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "exclusive lock".
#
42Z82.U=exclusif

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z83.U=partage instantan\u00E9

# A lock mode.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z84.U=partager

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z85.U=table

# A lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z86.U=ligne

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z87.U=partager la table

# Lock mode and granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
42Z88.U=partager la ligne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X00.U=Connect\u00E9 \u00E0

# Translators: This is part of query plan printout; the string is complete as is.
#
43X01.U=Num\u00E9ro de sous-requ\u00EAte de d\u00E9but

# Translators: This is part of query plan printout; the string is complete as is.
#
43X02.U=Tout ResultSet

# Translators: This is part of query plan printout; the string is complete as is.
#
43X03.U=Nombre d''ouvertures

# Translators: This is part of query plan printout; the string is complete as is.
#
43X04.U=Lignes affich\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X05.U=Ensemble de r\u00E9sultats source

# Translators: This is part of query plan printout; the string is complete as is.
#
43X06.U=Num\u00E9ro de sous-requ\u00EAte de fin

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X07.U=nombre de lignes estim\u00E9 par l''optimiseur : {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43X08.U=co\u00FBt estim\u00E9 par l''optimiseur : {0,number,###########0.00}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X09.U=secondes

# Translators: This is part of query plan printout; the string is complete as is.
#
43X11.U=Noeud

# Arguments:
#
#    {0} = methodName
#    {1} = className
#
43X12.U={0} non impl\u00E9ment\u00E9 actuellement pour {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X13.U=Supprimer ResultSet \u00E0 l''aide de

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X14.U=verrouillage des tables

# Lock granularity.
# Translators: This is part of query plan printout; the string is complete as is.
#
43X15.U=verrouillage des lignes

# Translators: This is part of query plan printout; the string is complete as is.
# This is shorthand for "deferred update".
#
43X16.U=diff\u00E9r\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X17.U=Lignes supprim\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X18.U=Index mis \u00E0 jour

43X19.U=Supprimer

# Translators: This is part of query plan printout; the string is complete as is.
#
43X20.U=ResultSet d''agr\u00E9gat scalaire distinct

# Translators: This is part of query plan printout; the string is complete as is.
#
43X21.U=Lignes entr\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X22.U=Agr\u00E9gat scalaire distinct

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X23.U=ResultSet d''analyse distincte pour {0} \u00E0 l''aide de {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X26.U=ResultSet d''analyse distincte pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X27.U=au niveau d''isolement {0} \u00E0 l''aide du verrouillage {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X28.U=informations d''analyse

# Translators: This is part of query plan printout; the string is complete as is.
#
43X29.U=La colonne distincte est le num\u00E9ro de colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X30.U=Les colonnes distinctes sont les num\u00E9ros de colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X31.U=Taille de la table de hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X32.U=Lignes filtr\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X33.U=dur\u00E9e next en millisecondes/ligne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X34.U=position de d\u00E9but

# Translators: This is part of query plan printout; the string is complete as is.
#
43X35.U=position d''arr\u00EAt

# Translators: This is part of query plan printout; the string is complete as is.
#
43X36.U=qualificatifs d''analyse

# Translators: This is part of query plan printout; the string is complete as is.
#
43X37.U=qualificatifs next

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X38.U=sur {0} \u00E0 l''aide de {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X39.U=Analyse distincte

# Translators: This is part of query plan printout; the string is complete as is.
#
43X40.U=Informations de tri

# Translators: This is part of query plan printout; the string is complete as is.
#
43X41.U=ResultSet d''agr\u00E9gat regroup\u00E9

# Translators: This is part of query plan printout; the string is complete as is.
#
43X42.U=Poss\u00E8de un agr\u00E9gat distinct

# Translators: This is part of query plan printout; the string is complete as is.
#
43X43.U=Par ordre de tri

# Translators: This is part of query plan printout; the string is complete as is.
#
43X44.U=Agr\u00E9gat regroup\u00E9

# Translators: This is part of query plan printout; the string is complete as is.
#
43X45.U=Jointure Exists par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X46.U=ResultSet de jointure Exists par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X47.U=Jointure par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X48.U=ResultSet de jointure par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X49.U=Jointure externe gauche par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X50.U=ResultSet de jointure externe gauche par hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43X51.U=ResultSet d''analyse du hachage pour {0} \u00E0 l''aide de {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X52.U=ResultSet d''analyse du hachage pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X53.U=La cl\u00E9 de hachage est le num\u00E9ro de colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X54.U=Les cl\u00E9s de hachage sont les num\u00E9ros de colonne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X55.U=Analyse du hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X56.U=Sous-requ\u00EAtes associ\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X57.U=ResultSet de table de hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43X58.U=Table de hachage

# Translators: This is part of query plan printout; the string is complete as is.
# Shorthand for "all columns".
#
43X59.U=toutes

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X60.U=ResultSet - Ligne d''index vers la ligne de base pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X61.U=Colonnes accessibles \u00E0 partir de la portion de m\u00E9moire

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X62.U=pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X63.U=Ligne d''index vers ligne de base

# Translators: This is part of query plan printout; the string is complete as is.
#
43X64.U=mode d''insertion : insertion en masse

# Translators: This is part of query plan printout; the string is complete as is.
#
43X65.U=mode d''insertion : normal (impossible d''effectuer une insertion en masse car la table n''est pas vide)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X66.U=mode d''insertion : normal

# Translators: This is part of query plan printout; the string is complete as is.
#
43X67.U=Ins\u00E9rer ResultSet \u00E0 l''aide de

# Translators: This is part of query plan printout; the string is complete as is.
#
43X68.U=Lignes ins\u00E9r\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X69.U=Ins\u00E9rer

# Translators: This is part of query plan printout; the string is complete as is.
#
43X70.U=Joindre

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = indexName
#
43X71.U=ResultSet de derni\u00E8re analyse de l''index des cl\u00E9s pour {0} \u00E0 l''aide de l''index {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = isolationLevel
#    {1} = lockString
#
43X72.U=au niveau d''isolement {0} \u00E0 l''aide du verrouillage {1} choisi par l''optimiseur

# Translators: This is part of query plan printout; the string is complete as is.
#
43X73.U=Analyse de table

# Translators: This is part of query plan printout; the string is complete as is.
#
43X74.U=Analyse d''index

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43X75.U=sur {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43X76.U=ResultSet mat\u00E9rialis\u00E9

# Translators: This is part of query plan printout; the string is complete as is.
#
43X77.U=dur\u00E9e de cr\u00E9ation de l''agglom\u00E9ration temporaire (millisecondes)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X78.U=dur\u00E9e d''extraction de l''agglom\u00E9ration temporaire (millisecondes)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X79.U=Lignes vues de la gauche

# Translators: This is part of query plan printout; the string is complete as is.
#
43X80.U=Lignes vues de la droite

# Translators: This is part of query plan printout; the string is complete as is.
#
43X81.U=Lignes renvoy\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X82.U=Ensemble de r\u00E9sultats de gauche

# Translators: This is part of query plan printout; the string is complete as is.
#
43X83.U=Ensemble de r\u00E9sultats de droite

# Translators: This is part of query plan printout; the string is complete as is.
#
43X84.U=Jointure Exists en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X85.U=ResultSet de jointure Exists en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X86.U=Jointure en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X87.U=ResultSet de jointure en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X88.U=Lignes de droite vides renvoy\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43X89.U=Jointure externe gauche en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X90.U=ResultSet de jointure externe gauche en boucle imbriqu\u00E9e

# Translators: This is part of query plan printout; the string is complete as is.
#
43X91.U=ResultSet normalis\u00E9

# Translators: This is part of query plan printout; the string is complete as is.
#
43X92.U=ResultSet \u00E0 valeur unique

# Translators: This is part of query plan printout; the string is complete as is.
#
43X93.U=ResultSet de projection-limitation

# Translators: This is part of query plan printout; the string is complete as is.
#
43X94.U=limitation

# Translators: This is part of query plan printout; the string is complete as is.
#
43X95.U=projection

# Translators: This is part of query plan printout; the string is complete as is.
#
43X96.U=dur\u00E9e de limitation (millisecondes)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X97.U=dur\u00E9e de projection (millisecondes)

# Translators: This is part of query plan printout; the string is complete as is.
#
43X98.U=Projection-limitation

# Translators: This is part of query plan printout; the string is complete as is.
#
43X99.U=ResultSet de ligne

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9A.U=ResultSet de nombre de lignes

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9B.U=Nombre de lignes

# Translators: This is part of query plan printout; the string is complete as is.
#
43X9C.U=ResultSet de fen\u00EAtre : 

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y00.U=ResultSet d''agr\u00E9gat scalaire

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y01.U=Optimisation de cl\u00E9 d''index

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y02.U=Agr\u00E9gat scalaire

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y03.U=ResultSet insensible au d\u00E9filement

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y04.U=Nombre de lectures \u00E0 partir de la table de hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y05.U=Nombre d''\u00E9critures dans la table de hachage

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y06.U=ResultSet de tri

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y07.U=Eliminer les doublons

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y08.U=Tri

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = constraintOrIndex
#    {2} = constraintOrIndexName
#
43Y09.U=ResultSet d''analyse d''index pour {0} \u00E0 l''aide de {1} {2}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#
43Y10.U=ResultSet d''analyse de table pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y11.U=Verrouillage r\u00E9el utilis\u00E9 : verrouillage au niveau de la table

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y12.U=Taille d''extraction

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y13.U=qualificatifs

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y14.U=ResultSet d''union

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableOrRow
#
43Y16.U=ResultSet de mise \u00E0 jour \u00E0 l''aide du verrouillage de {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y17.U=Lignes mises \u00E0 jour

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = javaClassName
#
43Y19.U=ResultSet de VTI pour {0}

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y20.U=VTI

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y21.U=Sous-requ\u00EAtes mat\u00E9rialis\u00E9es

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y22.U=Nom de l''instruction

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y23.U=Texte de l''instruction

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y24.U=Dur\u00E9e de l''analyse

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y25.U=Dur\u00E9e de la liaison

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y26.U=Dur\u00E9e de l''optimisation

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y27.U=Dur\u00E9e de la g\u00E9n\u00E9ration

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y28.U=Dur\u00E9e de la compilation

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y29.U=Dur\u00E9e de l''ex\u00E9cution

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y30.U=Horodatage de d\u00E9but de compilation

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y31.U=Horodatage de fin de compilation

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y32.U=Horodatage de d\u00E9but d''ex\u00E9cution

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y33.U=Horodatage de fin d''ex\u00E9cution

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y44.U=Texte du plan d''ex\u00E9cution de l''instruction

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = number
#
43Y45.U=Ex\u00E9cution 100%, {0} secondes

43Y46.U=Ins\u00E9rer l''\u00E9l\u00E9ment ResultSet de VTI

43Y47.U=Supprimer l''\u00E9l\u00E9ment ResultSet de VTI

43Y49.U=Ins\u00E9rer la VTI

43Y50.U=Supprimer la VTI

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y51.U=Supprimer l''\u00E9l\u00E9ment ResultSet en cascade

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y52.U=Supprimer l''\u00E9l\u00E9ment ResultSet en cascade \u00E0 l''aide de

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y53.U=Actions r\u00E9f\u00E9rentielles sur les tables d\u00E9pendantes

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y54.U=D\u00E9but de l''action r\u00E9f\u00E9rentielle sur la table d\u00E9pendante num\u00E9ro

# Translators: This is part of query plan printout; the string is complete as is.
#
43Y55.U=Fin de l''action r\u00E9f\u00E9rentielle sur la table d\u00E9pendante num\u00E9ro

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = tableName
#    {1} = userSuppliedOptimizerOverrides
#
43Y56.U=Les \u00E9l\u00E9ments de substitution d''optimiseur fournies par l''utilisateur pour {0} sont {1}

# Translators: This is part of query plan printout; the string is complete as is.
#
# Arguments:
#
#    {0} = userSuppliedOptimizerOverrides
#
43Y57.U=Les \u00E9l\u00E9ments de substitution d''optimiseur fournies par l''utilisateur pour la jointure sont {0}

44X00.U=Nom du type SQL

# Arguments:
#
#    {0} = url
#
46001=Exception lors de l''acc\u00E8s au fichier JAR \u00E0 l''aide de l''URL ''{0}''.

46J01=Le format de la signature de m\u00E9thode Java n''est pas valide.

# Arguments:
#
#    {0} = number
#    {1} = number
#
46J02=La signature de m\u00E9thode Java contient un nombre incorrect ({0}) de param\u00E8tres, valeur attendue {1}.

# Arguments:
#
#    {0} = prefix
#
54002=Une constante de cha\u00EEne commen\u00E7ant par ''{0}'' est trop longue.

54004=L''instruction SELECT contient trop d''\u00E9l\u00E9ments dans la liste SELECT, ORDER BY ou GROUP BY.

# Arguments:
#
#    {0} = operator
#    {1} = number
#
54006=La longueur r\u00E9sultant de l''op\u00E9ration {0} est sup\u00E9rieure \u00E0 {1}.

54008=L''instruction CREATE INDEX sp\u00E9cifie un trop grand nombre de colonnes (le maximum est 16).

# Arguments:
#
#    {0} = number
#    {1} = tableOrViewName
#    {2} = number
#
54011=Trop de colonnes ({0}) ont \u00E9t\u00E9 sp\u00E9cifi\u00E9es pour la table ou la vue {1}. La limite est {2}.

# Arguments:
#
#    {0} = number
#    {1} = procedureName
#    {2} = number
#
54023=Le nombre de param\u00E8tres maximal autoris\u00E9 pour une proc\u00E9dure a \u00E9t\u00E9 d\u00E9pass\u00E9. La limite est de {0} et le nombre de param\u00E8tres pour la proc\u00E9dure {1} est {2}.

54038=La profondeur maximale de d\u00E9clencheurs imbriqu\u00E9s a \u00E9t\u00E9 d\u00E9pass\u00E9e.

BIN01=(valeur de donn\u00E9es binaire non affich\u00E9e)

# Arguments:
#
#    {0} = columnName
#
S0022=La colonne ''{0}'' est introuvable.

# Arguments:
#
#    {0} = errorMessage
#    {1} = exceptionClassName
#
XJ001.U=Exception Java : ''{1} : {0}''.

# Arguments:
#
#    {0} = oldVersion
#    {1} = newVersion
#
XJ050.U=La base de donn\u00E9es n\u00E9cessite une mise \u00E0 niveau de la version {0}. D\u00E9finissez l''attribut ''upgrade=true'' sur l''URL de connexion JDBC pour permettre une mise \u00E0 niveau vers la version {1}.

XJ082.U=Les valeurs BLOB/CLOB ne sont pas autoris\u00E9es en tant que param\u00E8tres de m\u00E9thode ou r\u00E9cepteur.

# Arguments:
#
#    {0} = operation
#
XJ083.U=L''op\u00E9ration ''{0}'' n''est pas autoris\u00E9e car le ResultSet n''est pas un ResultSet pouvant \u00EAtre mis \u00E0 jour. 

# Arguments:
#
#    {0} = methodName
#
XJ084.U=La colonne ne correspond pas \u00E0 une colonne de la table de base. Impossible d''\u00E9mettre {0} sur cette colonne.

# Arguments:
#
#    {0} = xmlPackageName
#
XML00=Echec de la localisation de l''API ou des classes d''impl\u00E9mentation ''{0}''. Les op\u00E9rations XML ne sont pas autoris\u00E9es, sauf si ces classes figurent dans le chemin de classe.

# Arguments:
#
#    {0} = errorMessage
#
XML01=Exception inattendue rencontr\u00E9e lors du traitement XML : {0}

XN002.U=SECTKN non renvoy\u00E9.

XSAJ0.U=Type d''analyse

XSAJ1.U=Nombre de pages visit\u00E9es

XSAJ2.U=Nombre de lignes visit\u00E9es

XSAJ3.U=Nombre de lignes supprim\u00E9es visit\u00E9es

XSAJ4.U=Nombre de lignes qualifi\u00E9es

XSAJ5.U=Nombre de colonnes extraites

XSAJ6.U=Jeu de bits des colonnes extrait

XSAJ7.U=Hauteur de l''arborescence

XSAJ8.U=Type de tri

XSAJA.U=Nombre de lignes en entr\u00E9e

XSAJB.U=Nombre de lignes en sortie

XSAJC.U=Nombre d''ex\u00E9cutions de fusion

XSAJD.U=Taille des ex\u00E9cutions de fusion

XSAJE.U=Tout

# This is a type of conglomerate.
#
XSAJF.U=btree

# This is a type of conglomerate.
#
XSAJG.U=portion de m\u00E9moire

XSAJH.U=tri

# This is a type of sort.
#
XSAJI.U=externe

# This is a type of sort.
#
XSAJJ.U=interne

A001=Fatal : aucun service d''authentification n''existe pour le syst\u00E8me

A002=Fatal : aucun service d''authentification n''existe pour la base de donn\u00E9es

# Arguments:
#
#    {0} = propertyName
#
A011=Avertissement : aucun nom de serveur LDAP/d''h\u00F4te n''est mentionn\u00E9 dans la propri\u00E9t\u00E9 {0} ; utilisation de localhost:389

A020=Authentification non valide.

# Arguments:
#
#    {0} = className
#    {1} = fileName
#    {2} = errorMessage
#
C000=La classe {0} a \u00E9t\u00E9 enregistr\u00E9e dans le fichier {1}. Indiquez le fichier et les informations suivantes relatives \u00E0 l''exception au support technique : {2}

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C001=La classe {0} pr\u00E9sente un type de certificat inconnu dans le fichier JAR {1} ; le certificat X509 est attendu.

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = errorMessage
#
C002=Exception de s\u00E9curit\u00E9 g\u00E9n\u00E9r\u00E9e lors de l''acc\u00E8s \u00E0 la classe {0} dans le fichier JAR {1} : {2}

# Arguments:
#
#    {0} = jarName
#    {1} = errorMessage
#
C003=Exception lors du chargement du fichier JAR de la base de donn\u00E9es {0} - {1}

# Arguments:
#
#    {0} = className
#
C004=Chargeur de classe obsol\u00E8te pour la classe {0}

# Arguments:
#
#    {0} = classpath
#
C005=Chargeur de classe de la base de donn\u00E9es d\u00E9marr\u00E9 - derby.database.classpath = ''{0}''

# Arguments:
#
#    {0} = className
#    {1} = jarName
#
C006={0} a \u00E9t\u00E9 charg\u00E9 \u00E0 partir du fichier JAR de la base de donn\u00E9es {1}

# Arguments:
#
#    {0} = className
#    {1} = jarName
#    {2} = detailedError
#
C007=Exception lors du chargement de la classe {0} \u00E0 partir du fichier JAR {1} - {2}

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D000=:\nAmor\u00E7age de Derby (version {0}), instance {1} \ndans le r\u00E9pertoire de base de donn\u00E9es {2} en mode READ ONLY avec le chargeur de classe {3}. \nCharg\u00E9 de {4}.

# Arguments:
#
#    {0} = derbyVersion
#    {1} = id
#    {2} = directoryName
#    {3} = classloader
#    {4} = JarClassPath
#
D001=:\nAmor\u00E7age de Derby version {0} : instance {1} \ndans le r\u00E9pertoire de base de donn\u00E9es {2} avec le chargeur de classe {3}\nCharg\u00E9 de {4}

# Arguments:
#
#    {0} = id
#    {1} = dbDirectory
#    {2} = classloader
#
D002=:\nFermeture de l''instance {0} sur le r\u00E9pertoire de base de donn\u00E9es {1} avec le chargeur de classe {2} 

# Arguments:
#
#    {0} = databaseName
#    {1} = filePath
#
D004=La sauvegarde de la base de donn\u00E9es situ\u00E9e \u00E0 l''emplacement {0}, vers l''emplacement {1}, a d\u00E9marr\u00E9.

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D005=L''ancienne copie de sauvegarde a \u00E9t\u00E9 d\u00E9plac\u00E9e de {0} vers {1}

# Arguments:
#
#    {0} = filePath
#
D006=La sauvegarde du segment de donn\u00E9es vers l''emplacement {0} est termin\u00E9e. 

D007=La propri\u00E9t\u00E9 de base de donn\u00E9es service.properties a \u00E9t\u00E9 modifi\u00E9e pour utiliser l''unit\u00E9 de journalisation par d\u00E9faut

# Arguments:
#
#    {0} = errorMessage
#
D008=Erreur lors de la modification de la propri\u00E9t\u00E9 de base de donn\u00E9es service.properties, abandon de la sauvegarde : {0}

# Arguments:
#
#    {0} = filePath
#    {1} = filePath
#
D009=Le r\u00E9pertoire de journalisation a \u00E9t\u00E9 copi\u00E9 de {0} vers {1}

D010=Sauvegarde abandonn\u00E9e en raison d''une erreur

# Arguments:
#
#    {0} = filePath
#
D011=L''ancienne copie de sauvegarde situ\u00E9e sur {0} a \u00E9t\u00E9 enlev\u00E9e

# Arguments:
#
#    {0} = backupInstant
#
D012=Sauvegarde termin\u00E9e, l''instant de journalisation est situ\u00E9 \u00E0 {0} \n

# Arguments:
#
#    {0} = durabilityProperty
#    {1} = noSync
#
D013=Avertissement : la base de donn\u00E9es est amorc\u00E9e avec {0} = {1}. Lorsque ce mode est utilis\u00E9, il est possible que la base de donn\u00E9es ne puisse pas \u00EAtre r\u00E9cup\u00E9r\u00E9e, que des transactions valid\u00E9es (commit) soient perdues et que la base de donn\u00E9es soit dans un \u00E9tat incoh\u00E9rent. Utilisez ce mode uniquement lorsque ces cons\u00E9quences sont acceptables  \n

D015=Impossible de poursuivre la lecture car une autre transaction a modifi\u00E9 la valeur.

I024=La base de donn\u00E9es n''est pas disponible

I025=Pilote JDBC non disponible

# Arguments:
#
#    {0} = errorMessage
#
I026=Echec de l''inscription du pilote JDBC aupr\u00E8s de java.sql.DriverManager : {0}

I027=Aucune marque d\u00E9finie ou lue avant la limite d\u00E9pass\u00E9e.

I028=Erreur de lecture de flux c\u00F4t\u00E9 client lors du transfert de donn\u00E9es utilisateur sur le serveur.

# Arguments:
#
#    {0} = expectedCount
#    {1} = gotCount
#
I029=EOF atteinte pr\u00E9matur\u00E9ment ; attendu : {0}, obtenu : {1}.

# Arguments:
#
#    {0} = timestamp
#
J003={0} : fermeture du moteur Derby

J004=Identit\u00E9 de la base de donn\u00E9es

J005=Arr\u00EAter Derby

J006=D\u00E9sinscription d''AutoloadedDriver

J007=Cr\u00E9er une base de donn\u00E9es

J008=Aucun d\u00E9tail

J010=Crypter la base de donn\u00E9es sur le disque

J013=Mettre \u00E0 niveau la base de donn\u00E9es

J016=Fournisseur de services cryptographiques

J017=Algorithme de cryptographie

J018=Longueur de la cl\u00E9 de cryptographie

J019=Cl\u00E9 de cryptographie externe

J020=Cl\u00E9 de cryptographie secr\u00E8te

J021=Territoire de la base de donn\u00E9es

J022=Nom utilisateur

J023=Mot de passe de l''utilisateur

J025=Chemin du r\u00E9pertoire du journal

J028=Chemin de sauvegarde pour la r\u00E9cup\u00E9ration en aval

J029=Chemin de sauvegarde pour la cr\u00E9ation de base de donn\u00E9es \u00E0 partir de la sauvegarde

J030=Chemin de sauvegarde pour la restauration de base de donn\u00E9es \u00E0 partir de la sauvegarde

J031=Classement pour les types de donn\u00E9es alphanum\u00E9riques

# Arguments:
#
#    {0} = className
#
J100=Classe de serveur r\u00E9seau {0} introuvable. Le chemin de classe doit contenir le fichier derbynet.jar.

# Arguments:
#
#    {0} = className
#    {1} = errorMessage
#
J101=Impossible de charger la classe de serveur r\u00E9seau, {0}. {1} V\u00E9rifiez l''int\u00E9grit\u00E9 du fichier derbynet.jar.

# Arguments:
#
#    {0} = errorMessage
#
J102=Une exception a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e lors du d\u00E9marrage du serveur r\u00E9seau. {0}

# Arguments:
#
#    {0} = errorMessage
#
J103=Une exception a \u00E9t\u00E9 g\u00E9n\u00E9r\u00E9e lors de l''arr\u00EAt du serveur r\u00E9seau. {0}

J104=Cet objet est d\u00E9j\u00E0 ferm\u00E9.

J105=La pr\u00E9cision d\u00E9passe 31 chiffres.

J107=Erreur pour l''\u00E9l\u00E9ment de batch n\u00B0

# Arguments:
#
#    {0} = propertyName
#
J108=Le gestionnaire de s\u00E9curit\u00E9 n''autorise pas l''acc\u00E8s \u00E0 la propri\u00E9t\u00E9 syst\u00E8me {0}.

# Arguments:
#
#    {0} = errorMessage
#
J109=Configuration client TCP/IP incorrecte d\u00E9tect\u00E9e. Impossible de d\u00E9terminer l''adresse IP de l''h\u00F4te local : ''{0}''. Assurez-vous que la machine client poss\u00E8de une adresse IP correctement configur\u00E9e.

J110=M\u00E9canisme de s\u00E9curit\u00E9 non pris en charge

J111=Mot de passe manquant

J112=ID utilisateur manquant

J113=ID utilisateur ou mot de passe non valide

J114=ID utilisateur r\u00E9voqu\u00E9

J115=Nouveau mot de passe non valide

J116=Erreur du service de s\u00E9curit\u00E9 locale pour une op\u00E9ration qui ne peut pas \u00EAtre retent\u00E9e.

J117=SECTKN manquant sur ACCSEC alors qu''il est obligatoire, ou non valide

J118=Mot de passe arriv\u00E9 \u00E0 expiration

J120=Erreur de connexion non sp\u00E9cifi\u00E9e

J121=L''utilisateur n''est pas autoris\u00E9 \u00E0 acc\u00E9der \u00E0 la base de donn\u00E9es.

J122=Une commande demandant des services de la base de donn\u00E9es a \u00E9t\u00E9 \u00E9mise avant celle demandant un acc\u00E8s \u00E0 la base de donn\u00E9es (ACCRDB)

J123=La commande demand\u00E9e a rencontr\u00E9 une condition non structur\u00E9e propre \u00E0 l''impl\u00E9mentation pour laquelle aucun message structur\u00E9 n''existe (des informations suppl\u00E9mentaires sont peut-\u00EAtre disponibles dans le fichier derby.log enregistr\u00E9 sur le serveur).

J124=La commande d''acc\u00E8s \u00E0 la base de donn\u00E9es relationnelle (ACCRDB) ne peut \u00EAtre \u00E9mise car un acc\u00E8s \u00E0 la base de donn\u00E9es est en cours.

J125=Une erreur de non-concordance de descripteur de donn\u00E9es a \u00E9t\u00E9 d\u00E9tect\u00E9e.

# Arguments:
#
#    {0} = hexNumber
#
J126=Une erreur de protocole de conversation a \u00E9t\u00E9 d\u00E9tect\u00E9e. Motif : 0x{0}.

J128=Le curseur n''est pas ouvert.

J129=Une commande Open Query a \u00E9t\u00E9 \u00E9mise pour une requ\u00EAte d\u00E9j\u00E0 ouverte.

J130=Une erreur de protocole (description FDOCA non valide) a \u00E9t\u00E9 d\u00E9tect\u00E9e.

# Arguments:
#
#    {0} = hexNumber
#
J131=Une erreur de protocole (erreur de syntaxe du flux de donn\u00E9es) a \u00E9t\u00E9 d\u00E9tect\u00E9e. Cause : 0x{0}. Il s''agit peut-\u00EAtre d''une tentative de connexion en texte brut \u00E0 un serveur avec SSL activ\u00E9.

J132=Nom utilisateur pour la connexion

J133=Mot de passe de l''utilisateur pour la connexion

# Arguments:
#
#    {0} = maxStatements
#
J134=La propri\u00E9t\u00E9 maxStatements ne peut pas avoir de valeurs n\u00E9gatives : {0}

# Arguments:
#
#    {0} = transactionXid
#
J135=La transaction XA a expir\u00E9 et va \u00EAtre annul\u00E9e (rollback). Le XID de transaction est {0}.

# Arguments:
#
#    {0} = transactionXid
#
J136=Une transaction XA \u00E9tait associ\u00E9e \u00E0 la connexion en cours de fermeture. La transaction va \u00EAtre annul\u00E9e (rollback). Le XID de transaction est {0}.

L001=------------  D\u00E9but de message d''erreur -------------\n

L002=------------  Fin de message d''erreur -------------\n

L003=\n------------  D\u00E9but de pile d''erreurs d''arr\u00EAt -----------\n

L004=\n------------  Fin de pile d''erreurs d''arr\u00EAt -----------\n

L005=\n------------  D\u00E9but de pile d''erreurs -----------\n

L006=\n------------  Fin de pile d''erreurs -----------\n

L007=Avertissement : fichier journal introuvable, cr\u00E9ation d''un fichier journal. Possibilit\u00E9 d''incoh\u00E9rences dans la base de donn\u00E9es

# Arguments:
#
#    {0} = fileName
#
L008=Suppression d''un ancien fichier journal incompatible {0}

# Arguments:
#
#    {0} = fileName
#
L009=Suppression d''un ancien fichier journal {0}

# Arguments:
#
#    {0} = fileName
#    {1} = position
#    {2} = position
#
L010=Enregistrement de journal incomplet d\u00E9tect\u00E9 dans le fichier {0} ; effacement du fichier journal de la position {1} jusqu''\u00E0 la fin du fichier \u00E0 la position {2}.

L011=Le d\u00E9mon des points de contr\u00F4le a intercept\u00E9 une exception standard

# Arguments:
#
#    {0} = transactionID
#
L012=L''enregistrement de journal n''est pas le premier, mais la transaction n''est pas dans la table des transactions : {0}

# Arguments:
#
#    {0} = transactionID
#
L013=L''enregistrement de journal est le premier, mais la transaction est d\u00E9j\u00E0 dans la table des transactions : {0}

L014=Instant de d\u00E9part incorrect

# Arguments:
#
#    {0} = fileName
#
L015=Le nouveau fichier journal existe et ne peut pas \u00EAtre supprim\u00E9 {0}

# Arguments:
#
#    {0} = fileName
#
L016=Impossible de cr\u00E9er le fichier journal {0}

# Arguments:
#
#    {0} = fileName
#    {1} = errorMessage
#
L017=Impossible de cr\u00E9er le fichier journal {0} en raison de {1}

# Arguments:
#
#    {0} = fileName
#
L018=Le syst\u00E8me peut se trouver dans un \u00E9tat incoh\u00E9rent ; fichier manquant {0}

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#
L020=Avertissement : la base de donn\u00E9es a \u00E9t\u00E9 amorc\u00E9e au moins une fois avec {0} = {1}. Lorsque ce mode est utilis\u00E9, il est possible que la base de donn\u00E9es ne puisse pas \u00EAtre r\u00E9cup\u00E9r\u00E9e, que des transactions valid\u00E9es (commit) soient perdues et que la base de donn\u00E9es soit dans un \u00E9tat incoh\u00E9rent. Des erreurs inattendues peuvent se produire.\n

# Arguments:
#
#    {0} = testModeProperty
#    {1} = testMode
#    {2} = testModeProperty
#    {3} = testMode
#
L021=Avertissement : la base de donn\u00E9es a \u00E9t\u00E9 pr\u00E9c\u00E9demment amorc\u00E9e ou est actuellement amorc\u00E9e avec {0} ayant comme valeur {1}. Ce mode {0} = {1} ne garantit pas la capacit\u00E9 de r\u00E9cup\u00E9ration et peut \u00EAtre \u00E0 l''origine de l''erreur d''amor\u00E7age.\n

L022=Avertissement : en raison d''un probl\u00E8me de droits d''acc\u00E8s aux fichiers journaux, la base de donn\u00E9es est pass\u00E9e en lecture seule. \n               

# Arguments:
#
#    {0} = timestamp
#
R001=----  Message d''erreur de lancement de la r\u00E9plication ({0}) ----

R002=--------------------  Message d''erreur de fin de la r\u00E9plication ---------------------

# Arguments:
#
#    {0} = dbname
#
R003=R\u00F4le esclave de r\u00E9plication d\u00E9marr\u00E9 pour la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R004=Le r\u00F4le esclave de r\u00E9plication a \u00E9t\u00E9 arr\u00EAt\u00E9 pour la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R005=L''esclave de r\u00E9plication a rencontr\u00E9 une erreur fatale pour la base de donn\u00E9es ''{0}''. La r\u00E9plication sera arr\u00EAt\u00E9e.

# Arguments:
#
#    {0} = dbname
#
R006=Perte de la connexion avec le ma\u00EEtre de r\u00E9plication de la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R007=R\u00F4le ma\u00EEtre de r\u00E9plication d\u00E9marr\u00E9 pour la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = dbname
#
R008=R\u00F4le ma\u00EEtre de r\u00E9plication arr\u00EAt\u00E9 pour la base de donn\u00E9es ''{0}''.

R009=Une exception s''est produite lors de l''exp\u00E9dition du journal.

# Arguments:
#
#    {0} = dbname
#
R010=Le ma\u00EEtre de r\u00E9plication essaie de se reconnecter \u00E0 l''esclave pour la base de donn\u00E9es ''{0}''.

# Arguments:
#
#    {0} = dbname
#    {1} = hostname
#    {2} = port
#
R011=La base de donn\u00E9es esclave de r\u00E9plication ''{0}'' \u00E9coute les connexions \u00E0 partir du ma\u00EEtre sur ''{1}:{2}''.

R012=Descripteur de connexion de r\u00E9plication non valide.

# Arguments:
#
#    {0} = timestamp
#    {1} = message
#
R013=Message de r\u00E9plication ({0}) : {1}

# Arguments:
#
#    {0} = dbname
#
R020=Basculement effectu\u00E9 pour la base de donn\u00E9es ''{0}''.

# Translators: Please translate the ALL CAPS words.
#
M001=\n\# ********************************************************************\n\# ***                Ne modifiez PAS ce fichier.                ***\n\# *** LA MODIFICATION DE SON CONTENU PEUT ENTRAINER UNE ALTERATION DES DONNEES. ***\n\# ********************************************************************

M002=Propri\u00E9t\u00E9s de service endommag\u00E9es/manquantes restaur\u00E9es \u00E0 partir du fichier de sauvegarde.

M003=Fichier de sauvegarde des propri\u00E9t\u00E9s de service restantes supprim\u00E9.

# Arguments:
#
#    {0} = servicePropertiesBackupFile
#
M004=Echec de la suppression du fichier de sauvegarde des propri\u00E9t\u00E9s de service restantes ; supprimez-le manuellement : {0}

N001=Cette erreur est due \u00E0 l''erreur suivante.
